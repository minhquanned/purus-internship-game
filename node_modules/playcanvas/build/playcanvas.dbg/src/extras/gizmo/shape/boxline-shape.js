import { Quat } from '../../../core/math/quat.js';
import { Vec3 } from '../../../core/math/vec3.js';
import { Entity } from '../../../framework/entity.js';
import { BoxGeometry } from '../../../scene/geometry/box-geometry.js';
import { CylinderGeometry } from '../../../scene/geometry/cylinder-geometry.js';
import { TriData } from '../tri-data.js';
import { Shape } from './shape.js';

const tmpV1 = new Vec3();
const tmpV2 = new Vec3();
const tmpQ1 = new Quat();
class BoxLineShape extends Shape {
  constructor(device, options = {}) {
    super(device, options);
    this._gap = 0;
    this._lineThickness = 0.02;
    this._lineLength = 0.5;
    this._boxSize = 0.12;
    this._tolerance = 0.1;
    this._box = void 0;
    this._line = void 0;
    this.triData = [new TriData(new BoxGeometry()), new TriData(new CylinderGeometry(), 1)];
    this._createBoxLine();
  }
  set gap(value) {
    this._gap = value != null ? value : 0;
    this._updateLine();
    this._updateBox();
  }
  get gap() {
    return this._gap;
  }
  set lineThickness(value) {
    this._lineThickness = value != null ? value : 1;
    this._updateLine();
    this._updateBox();
  }
  get lineThickness() {
    return this._lineThickness;
  }
  set lineLength(value) {
    this._lineLength = value != null ? value : 1;
    this._updateLine();
    this._updateBox();
  }
  get lineLength() {
    return this._lineLength;
  }
  set boxSize(value) {
    this._boxSize = value != null ? value : 1;
    this._updateBox();
  }
  get boxSize() {
    return this._boxSize;
  }
  set tolerance(value) {
    this._tolerance = value;
    this._updateLine();
  }
  get tolerance() {
    return this._tolerance;
  }
  _createBoxLine() {
    this._createRoot('boxLine');

    // box
    this._box = new Entity(`box:${this.axis}`);
    this.entity.addChild(this._box);
    this._updateBox();
    this._addRenderMesh(this._box, 'box', this._shading);

    // line
    this._line = new Entity(`line:${this.axis}`);
    this.entity.addChild(this._line);
    this._updateLine();
    this._addRenderMesh(this._line, 'cylinder', this._shading);
  }
  _updateBox() {
    // intersect
    tmpV1.set(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
    tmpQ1.set(0, 0, 0, 1);
    tmpV2.set(this._boxSize, this._boxSize, this._boxSize);
    this.triData[0].setTransform(tmpV1, tmpQ1, tmpV2);

    // render
    this._box.setLocalPosition(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
    this._box.setLocalScale(this._boxSize, this._boxSize, this._boxSize);
  }
  _updateLine() {
    // intersect
    tmpV1.set(0, this._gap + this._lineLength * 0.5, 0);
    tmpQ1.set(0, 0, 0, 1);
    tmpV2.set(this._lineThickness + this._tolerance, this._lineLength, this._lineThickness + this._tolerance);
    this.triData[1].setTransform(tmpV1, tmpQ1, tmpV2);

    // render
    this._line.setLocalPosition(0, this._gap + this._lineLength * 0.5, 0);
    this._line.setLocalScale(this._lineThickness, this._lineLength, this._lineThickness);
  }
}

export { BoxLineShape };
