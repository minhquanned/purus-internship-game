import { TorusGeometry } from '../../../scene/geometry/torus-geometry.js';
import { TriData } from '../tri-data.js';
import { Shape } from './shape.js';

const TORUS_RENDER_SEGMENTS = 80;
const TORUS_INTERSECT_SEGMENTS = 20;
class ArcShape extends Shape {
	constructor(device, options = {}) {
		var _options$tubeRadius, _options$ringRadius, _options$sectorAngle;
		super(device, options);
		this._tubeRadius = 0.01;
		this._ringRadius = 0.5;
		this._sectorAngle = void 0;
		this._lightDir = void 0;
		this._tolerance = 0.05;
		this._tubeRadius = (_options$tubeRadius = options.tubeRadius) != null ? _options$tubeRadius : this._tubeRadius;
		this._ringRadius = (_options$ringRadius = options.ringRadius) != null ? _options$ringRadius : this._ringRadius;
		this._sectorAngle = (_options$sectorAngle = options.sectorAngle) != null ? _options$sectorAngle : this._sectorAngle;
		this.triData = [new TriData(this._createTorusGeometry())];
		this._createDisk();
	}
	_createTorusGeometry() {
		return new TorusGeometry({
			tubeRadius: this._tubeRadius + this._tolerance,
			ringRadius: this._ringRadius,
			sectorAngle: this._sectorAngle,
			segments: TORUS_INTERSECT_SEGMENTS
		});
	}
	_createTorusMesh(sectorAngle) {
		const geom = new TorusGeometry({
			tubeRadius: this._tubeRadius,
			ringRadius: this._ringRadius,
			sectorAngle: sectorAngle,
			segments: TORUS_RENDER_SEGMENTS
		});
		return this._createMesh(geom, this._shading);
	}
	_createDisk() {
		this._createRoot('disk');
		this._createRenderComponent(this.entity, [this._createTorusMesh(this._sectorAngle), this._createTorusMesh(360)]);
		this.drag(false);
	}
	set tubeRadius(value) {
		this._tubeRadius = value != null ? value : 0.1;
		this._updateTransform();
	}
	get tubeRadius() {
		return this._tubeRadius;
	}
	set ringRadius(value) {
		this._ringRadius = value != null ? value : 0.1;
		this._updateTransform();
	}
	get ringRadius() {
		return this._ringRadius;
	}
	set tolerance(value) {
		this._tolerance = value;
		this._updateTransform();
	}
	get tolerance() {
		return this._tolerance;
	}
	_updateTransform() {
		this.triData[0].fromGeometry(this._createTorusGeometry());
		this.meshInstances[0].mesh = this._createTorusMesh(this._sectorAngle);
		this.meshInstances[1].mesh = this._createTorusMesh(360);
	}
	drag(state) {
		this.meshInstances[0].visible = !state;
		this.meshInstances[1].visible = state;
	}
	hide(state) {
		if (state) {
			this.meshInstances[0].visible = false;
			this.meshInstances[1].visible = false;
			return;
		}
		this.drag(false);
	}
}

export { ArcShape };
