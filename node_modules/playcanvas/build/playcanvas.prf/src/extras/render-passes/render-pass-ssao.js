import { Color } from '../../core/math/color.js';
import { PIXELFORMAT_R8, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { Texture } from '../../platform/graphics/texture.js';
import { RenderPassShaderQuad } from '../../scene/graphics/render-pass-shader-quad.js';
import { shaderChunks } from '../../scene/shader-lib/chunks/chunks.js';
import { RenderPassDepthAwareBlur } from './render-pass-depth-aware-blur.js';

const fs = `
	varying vec2 uv0;
	uniform vec2 uInvResolution;
	uniform float uAspect;
	#define saturate(x) clamp(x,0.0,1.0)
	highp float getWFromProjectionMatrix(const mat4 p, const vec3 v) {
		return -v.z;
	}
	highp float getViewSpaceZFromW(const mat4 p, const float w) {
		return -w;
	}
	const float kLog2LodRate = 3.0;
	float random(const highp vec2 w) {
		const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);
		return fract(m.z * fract(dot(w, m.xy)));
	}
	highp vec2 getFragCoord() {
		return gl_FragCoord.xy;
	}
	highp vec3 computeViewSpacePositionFromDepth(highp vec2 uv, highp float linearDepth) {
		return vec3((0.5 - uv) * vec2(uAspect, 1.0) * linearDepth, linearDepth);
	}
	highp vec3 faceNormal(highp vec3 dpdx, highp vec3 dpdy) {
		return normalize(cross(dpdx, dpdy));
	}
	highp vec3 computeViewSpaceNormal(const highp vec3 position) {
		return faceNormal(dFdx(position), dFdy(position));
	}
	highp vec3 computeViewSpaceNormal(const highp vec3 position, const highp vec2 uv) {
		highp vec2 uvdx = uv + vec2(uInvResolution.x, 0.0);
		highp vec2 uvdy = uv + vec2(0.0, uInvResolution.y);
		highp vec3 px = computeViewSpacePositionFromDepth(uvdx, -getLinearScreenDepth(uvdx));
		highp vec3 py = computeViewSpacePositionFromDepth(uvdy, -getLinearScreenDepth(uvdy));
		highp vec3 dpdx = px - position;
		highp vec3 dpdy = py - position;
		return faceNormal(dpdx, dpdy);
	}
	uniform vec2 uSampleCount;
	uniform float uSpiralTurns;
	#define PI (3.14159)
	vec3 tapLocation(float i, const float noise) {
		float offset = ((2.0 * PI) * 2.4) * noise;
		float angle = ((i * uSampleCount.y) * uSpiralTurns) * (2.0 * PI) + offset;
		float radius = (i + noise + 0.5) * uSampleCount.y;
		return vec3(cos(angle), sin(angle), radius * radius);
	}
	highp vec2 startPosition(const float noise) {
		float angle = ((2.0 * PI) * 2.4) * noise;
		return vec2(cos(angle), sin(angle));
	}
	uniform vec2 uAngleIncCosSin;
	highp mat2 tapAngleStep() {
		highp vec2 t = uAngleIncCosSin;
		return mat2(t.x, t.y, -t.y, t.x);
	}
	vec3 tapLocationFast(float i, vec2 p, const float noise) {
		float radius = (i + noise + 0.5) * uSampleCount.y;
		return vec3(p, radius * radius);
	}
	uniform float uMaxLevel;
	uniform float uInvRadiusSquared;
	uniform float uMinHorizonAngleSineSquared;
	uniform float uBias;
	uniform float uPeak2;
	void computeAmbientOcclusionSAO(inout float occlusion, float i, float ssDiskRadius,
			const highp vec2 uv, const highp vec3 origin, const vec3 normal,
			const vec2 tapPosition, const float noise) {
		vec3 tap = tapLocationFast(i, tapPosition, noise);
		float ssRadius = max(1.0, tap.z * ssDiskRadius);
		vec2 uvSamplePos = uv + vec2(ssRadius * tap.xy) * uInvResolution;
		float level = clamp(floor(log2(ssRadius)) - kLog2LodRate, 0.0, float(uMaxLevel));
		highp float occlusionDepth = -getLinearScreenDepth(uvSamplePos);
		highp vec3 p = computeViewSpacePositionFromDepth(uvSamplePos, occlusionDepth);
		vec3 v = p - origin;
		float vv = dot(v, v);
		float vn = dot(v, normal);
		float w = max(0.0, 1.0 - vv * uInvRadiusSquared);
		w = w * w;
		w *= step(vv * uMinHorizonAngleSineSquared, vn * vn);
		occlusion += w * max(0.0, vn + origin.z * uBias) / (vv + uPeak2);
	}
	uniform float uProjectionScaleRadius;
	uniform float uIntensity;
	float scalableAmbientObscurance(highp vec2 uv, highp vec3 origin, vec3 normal) {
		float noise = random(getFragCoord());
		highp vec2 tapPosition = startPosition(noise);
		highp mat2 angleStep = tapAngleStep();
		float ssDiskRadius = -(uProjectionScaleRadius / origin.z);
		float occlusion = 0.0;
		for (float i = 0.0; i < uSampleCount.x; i += 1.0) {
			computeAmbientOcclusionSAO(occlusion, i, ssDiskRadius, uv, origin, normal, tapPosition, noise);
			tapPosition = angleStep * tapPosition;
		}
		return occlusion;
	}
	uniform float uPower;
	void main() {
		highp vec2 uv = uv0;
		highp float depth = -getLinearScreenDepth(uv0);
		highp vec3 origin = computeViewSpacePositionFromDepth(uv, depth);
		vec3 normal = computeViewSpaceNormal(origin, uv);
		float occlusion = 0.0;
		if (uIntensity > 0.0) {
			occlusion = scalableAmbientObscurance(uv, origin, normal);
		}
		float ao = max(0.0, 1.0 - occlusion * uIntensity);
		ao = pow(ao, uPower);
		gl_FragColor = vec4(ao, ao, ao, 1.0);
	}
`;
class RenderPassSsao extends RenderPassShaderQuad {
	constructor(device, sourceTexture, cameraComponent, blurEnabled) {
		super(device);
		this.radius = 5;
		this.intensity = 1;
		this.power = 1;
		this.sampleCount = 10;
		this.minAngle = 5;
		this.ssaoTexture = void 0;
		this._scale = 1;
		this.sourceTexture = sourceTexture;
		this.cameraComponent = cameraComponent;
		this.shader = this.createQuadShader('SsaoShader', shaderChunks.screenDepthPS + fs);
		const rt = this.createRenderTarget('SsaoFinalTexture');
		this.ssaoTexture = rt.colorBuffer;
		this.init(rt, {
			resizeSource: this.sourceTexture
		});
		const clearColor = new Color(0, 0, 0, 0);
		this.setClearColor(clearColor);
		if (blurEnabled) {
			const blurRT = this.createRenderTarget('SsaoTempTexture');
			const blurPassHorizontal = new RenderPassDepthAwareBlur(device, rt.colorBuffer, true);
			blurPassHorizontal.init(blurRT, {
				resizeSource: rt.colorBuffer
			});
			blurPassHorizontal.setClearColor(clearColor);
			const blurPassVertical = new RenderPassDepthAwareBlur(device, blurRT.colorBuffer, false);
			blurPassVertical.init(rt, {
				resizeSource: rt.colorBuffer
			});
			blurPassVertical.setClearColor(clearColor);
			this.afterPasses.push(blurPassHorizontal);
			this.afterPasses.push(blurPassVertical);
		}
		this.ssaoTextureId = device.scope.resolve('ssaoTexture');
		this.ssaoTextureSizeInvId = device.scope.resolve('ssaoTextureSizeInv');
	}
	destroy() {
		var _this$renderTarget, _this$renderTarget2;
		(_this$renderTarget = this.renderTarget) == null || _this$renderTarget.destroyTextureBuffers();
		(_this$renderTarget2 = this.renderTarget) == null || _this$renderTarget2.destroy();
		this.renderTarget = null;
		if (this.afterPasses.length > 0) {
			const blurRt = this.afterPasses[0].renderTarget;
			blurRt == null || blurRt.destroyTextureBuffers();
			blurRt == null || blurRt.destroy();
		}
		this.afterPasses.forEach(pass => pass.destroy());
		this.afterPasses.length = 0;
		super.destroy();
	}
	set scale(value) {
		this._scale = value;
		this.options.scaleX = value;
		this.options.scaleY = value;
	}
	get scale() {
		return this._scale;
	}
	createRenderTarget(name) {
		return new RenderTarget({
			depth: false,
			colorBuffer: new Texture(this.device, {
				name: name,
				width: 1,
				height: 1,
				format: PIXELFORMAT_R8,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			})
		});
	}
	execute() {
		const {
			device,
			sourceTexture,
			sampleCount,
			minAngle,
			scale
		} = this;
		const {
			width,
			height
		} = this.renderTarget.colorBuffer;
		const scope = device.scope;
		scope.resolve('uAspect').setValue(width / height);
		scope.resolve('uInvResolution').setValue([1.0 / width, 1.0 / height]);
		scope.resolve('uSampleCount').setValue([sampleCount, 1.0 / sampleCount]);
		const minAngleSin = Math.sin(minAngle * Math.PI / 180.0);
		scope.resolve('uMinHorizonAngleSineSquared').setValue(minAngleSin * minAngleSin);
		const spiralTurns = 10.0;
		const step = 1.0 / (sampleCount - 0.5) * spiralTurns * 2.0 * 3.141;
		const radius = this.radius * scale;
		const bias = 0.001;
		const peak = 0.1 * radius;
		const intensity = 2 * (peak * 2.0 * 3.141) * this.intensity / sampleCount;
		const projectionScale = 0.5 * sourceTexture.height * scale;
		scope.resolve('uSpiralTurns').setValue(spiralTurns);
		scope.resolve('uAngleIncCosSin').setValue([Math.cos(step), Math.sin(step)]);
		scope.resolve('uMaxLevel').setValue(0.0);
		scope.resolve('uInvRadiusSquared').setValue(1.0 / (radius * radius));
		scope.resolve('uBias').setValue(bias);
		scope.resolve('uPeak2').setValue(peak * peak);
		scope.resolve('uIntensity').setValue(intensity);
		scope.resolve('uPower').setValue(this.power);
		scope.resolve('uProjectionScaleRadius').setValue(projectionScale * radius);
		super.execute();
	}
	after() {
		this.ssaoTextureId.setValue(this.ssaoTexture);
		const srcTexture = this.sourceTexture;
		this.ssaoTextureSizeInvId.setValue([1.0 / srcTexture.width, 1.0 / srcTexture.height]);
	}
}

export { RenderPassSsao };
