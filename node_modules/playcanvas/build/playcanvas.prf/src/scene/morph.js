import { RefCountedObject } from '../core/ref-counted-object.js';
import { Vec3 } from '../core/math/vec3.js';
import { FloatPacking } from '../core/math/float-packing.js';
import { BoundingBox } from '../core/shape/bounding-box.js';
import { PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA16U, isIntegerPixelFormat, PIXELFORMAT_RGB32F, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, SEMANTIC_ATTR15, TYPE_UINT32 } from '../platform/graphics/constants.js';
import { Texture } from '../platform/graphics/texture.js';
import { VertexBuffer } from '../platform/graphics/vertex-buffer.js';
import { VertexFormat } from '../platform/graphics/vertex-format.js';

class Morph extends RefCountedObject {
	constructor(targets, graphicsDevice, {
		preferHighPrecision = false
	} = {}) {
		var _this$_renderTextureF;
		super();
		this._aabb = void 0;
		this.preferHighPrecision = void 0;
		this.device = graphicsDevice;
		this.preferHighPrecision = preferHighPrecision;
		this._targets = targets.slice();
		const device = this.device;
		const renderableHalf = device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;
		const renderableFloat = device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;
		this._renderTextureFormat = this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;
		this._renderTextureFormat = (_this$_renderTextureF = this._renderTextureFormat) != null ? _this$_renderTextureF : PIXELFORMAT_RGBA16U;
		this.intRenderFormat = isIntegerPixelFormat(this._renderTextureFormat);
		this._textureFormat = this.preferHighPrecision ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;
		this._init();
		this._updateMorphFlags();
	}
	get aabb() {
		if (!this._aabb) {
			const min = new Vec3();
			const max = new Vec3();
			for (let i = 0; i < this._targets.length; i++) {
				const targetAabb = this._targets[i].aabb;
				min.min(targetAabb.getMin());
				max.max(targetAabb.getMax());
			}
			this._aabb = new BoundingBox();
			this._aabb.setMinMax(min, max);
		}
		return this._aabb;
	}
	get morphPositions() {
		return this._morphPositions;
	}
	get morphNormals() {
		return this._morphNormals;
	}
	_init() {
		this._initTextureBased();
		for (let i = 0; i < this._targets.length; i++) {
			this._targets[i]._postInit();
		}
	}
	_findSparseSet(deltaArrays, ids, usedDataIndices) {
		let freeIndex = 1;
		const dataCount = deltaArrays[0].length;
		for (let v = 0; v < dataCount; v += 3) {
			let vertexUsed = false;
			for (let i = 0; i < deltaArrays.length; i++) {
				const data = deltaArrays[i];
				if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
					vertexUsed = true;
					break;
				}
			}
			if (vertexUsed) {
				ids.push(freeIndex);
				usedDataIndices.push(v / 3);
				freeIndex++;
			} else {
				ids.push(0);
			}
		}
		return freeIndex;
	}
	_initTextureBased() {
		const deltaArrays = [],
			deltaInfos = [];
		for (let i = 0; i < this._targets.length; i++) {
			const target = this._targets[i];
			if (target.options.deltaPositions) {
				deltaArrays.push(target.options.deltaPositions);
				deltaInfos.push({
					target: target,
					name: 'texturePositions'
				});
			}
			if (target.options.deltaNormals) {
				deltaArrays.push(target.options.deltaNormals);
				deltaInfos.push({
					target: target,
					name: 'textureNormals'
				});
			}
		}
		const ids = [],
			usedDataIndices = [];
		const freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices);
		const maxTextureSize = this.device.maxTextureSize;
		let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
		morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
		const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);
		if (morphTextureHeight > maxTextureSize) {
			return false;
		}
		this.morphTextureWidth = morphTextureWidth;
		this.morphTextureHeight = morphTextureHeight;
		let halfFloat = false;
		let numComponents = 3;
		const float2Half = FloatPacking.float2Half;
		if (this._textureFormat === PIXELFORMAT_RGBA16F) {
			halfFloat = true;
			numComponents = 4;
		}
		const textures = [];
		for (let i = 0; i < deltaArrays.length; i++) {
			textures.push(this._createTexture('MorphTarget', this._textureFormat));
		}
		for (let i = 0; i < deltaArrays.length; i++) {
			const data = deltaArrays[i];
			const texture = textures[i];
			const textureData = texture.lock();
			if (halfFloat) {
				for (let v = 0; v < usedDataIndices.length; v++) {
					const index = usedDataIndices[v] * 3;
					const dstIndex = v * numComponents + numComponents;
					textureData[dstIndex] = float2Half(data[index]);
					textureData[dstIndex + 1] = float2Half(data[index + 1]);
					textureData[dstIndex + 2] = float2Half(data[index + 2]);
				}
			} else {
				for (let v = 0; v < usedDataIndices.length; v++) {
					const index = usedDataIndices[v] * 3;
					const dstIndex = v * numComponents + numComponents;
					textureData[dstIndex] = data[index];
					textureData[dstIndex + 1] = data[index + 1];
					textureData[dstIndex + 2] = data[index + 2];
				}
			}
			texture.unlock();
			const target = deltaInfos[i].target;
			target._setTexture(deltaInfos[i].name, texture);
		}
		const formatDesc = [{
			semantic: SEMANTIC_ATTR15,
			components: 1,
			type: TYPE_UINT32,
			asInt: true
		}];
		this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids.length), ids.length, {
			data: new Uint32Array(ids)
		});
		return true;
	}
	destroy() {
		var _this$vertexBufferIds;
		(_this$vertexBufferIds = this.vertexBufferIds) == null || _this$vertexBufferIds.destroy();
		this.vertexBufferIds = null;
		for (let i = 0; i < this._targets.length; i++) {
			this._targets[i].destroy();
		}
		this._targets.length = 0;
	}
	get targets() {
		return this._targets;
	}
	_updateMorphFlags() {
		this._morphPositions = false;
		this._morphNormals = false;
		for (let i = 0; i < this._targets.length; i++) {
			const target = this._targets[i];
			if (target.morphPositions) {
				this._morphPositions = true;
			}
			if (target.morphNormals) {
				this._morphNormals = true;
			}
		}
	}
	_createTexture(name, format) {
		return new Texture(this.device, {
			width: this.morphTextureWidth,
			height: this.morphTextureHeight,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			name: name
		});
	}
}

export { Morph };
