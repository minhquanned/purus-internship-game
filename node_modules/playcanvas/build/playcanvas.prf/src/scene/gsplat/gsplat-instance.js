import { Mat4 } from '../../core/math/mat4.js';
import { Vec3 } from '../../core/math/vec3.js';
import { PIXELFORMAT_R32U, SEMANTIC_ATTR13, TYPE_UINT32, BUFFER_STATIC } from '../../platform/graphics/constants.js';
import { DITHER_NONE } from '../constants.js';
import { MeshInstance } from '../mesh-instance.js';
import { Mesh } from '../mesh.js';
import { GSplatSorter } from './gsplat-sorter.js';
import { VertexFormat } from '../../platform/graphics/vertex-format.js';
import { VertexBuffer } from '../../platform/graphics/vertex-buffer.js';

const mat = new Mat4();
const cameraPosition = new Vec3();
const cameraDirection = new Vec3();
const viewport = [0, 0];
class GSplatInstance {
	constructor(splat, options) {
		this.splat = void 0;
		this.mesh = void 0;
		this.meshInstance = void 0;
		this.material = void 0;
		this.orderTexture = void 0;
		this.options = {};
		this.sorter = null;
		this.lastCameraPosition = new Vec3();
		this.lastCameraDirection = new Vec3();
		this.cameras = [];
		this.splat = splat;
		options = Object.assign(this.options, options);
		const device = splat.device;
		this.orderTexture = this.splat.createTexture('splatOrder', PIXELFORMAT_R32U, this.splat.evalTextureSize(this.splat.numSplats));
		this.createMaterial(options);
		const splatInstanceSize = 128;
		const numSplats = Math.ceil(splat.numSplats / splatInstanceSize) * splatInstanceSize;
		const numSplatInstances = numSplats / splatInstanceSize;
		const indexData = new Uint32Array(numSplatInstances);
		for (let i = 0; i < numSplatInstances; ++i) {
			indexData[i] = i * splatInstanceSize;
		}
		const vertexFormat = new VertexFormat(device, [{
			semantic: SEMANTIC_ATTR13,
			components: 1,
			type: TYPE_UINT32,
			asInt: true
		}]);
		const indicesVB = new VertexBuffer(device, vertexFormat, numSplatInstances, {
			usage: BUFFER_STATIC,
			data: indexData.buffer
		});
		const meshPositions = new Float32Array(12 * splatInstanceSize);
		const meshIndices = new Uint32Array(6 * splatInstanceSize);
		for (let i = 0; i < splatInstanceSize; ++i) {
			meshPositions.set([-2, -2, i, 2, -2, i, 2, 2, i, -2, 2, i], i * 12);
			const b = i * 4;
			meshIndices.set([0 + b, 1 + b, 2 + b, 0 + b, 2 + b, 3 + b], i * 6);
		}
		const mesh = new Mesh(device);
		mesh.setPositions(meshPositions, 3);
		mesh.setIndices(meshIndices);
		mesh.update();
		this.mesh = mesh;
		this.mesh.aabb.copy(splat.aabb);
		this.meshInstance = new MeshInstance(this.mesh, this.material);
		this.meshInstance.setInstancing(indicesVB, true);
		this.meshInstance.gsplatInstance = this;
		this.meshInstance.instancingCount = 0;
		this.centers = new Float32Array(splat.centers);
		if (!options.dither || options.dither === DITHER_NONE) {
			this.sorter = new GSplatSorter();
			this.sorter.init(this.orderTexture, this.centers);
			this.sorter.on('updated', count => {
				this.meshInstance.instancingCount = Math.ceil(count / splatInstanceSize);
				const tex_params = this.material.getParameter('tex_params');
				if (tex_params != null && tex_params.data) {
					tex_params.data[0] = count;
				}
			});
		}
	}
	destroy() {
		var _this$material, _this$meshInstance, _this$sorter;
		(_this$material = this.material) == null || _this$material.destroy();
		(_this$meshInstance = this.meshInstance) == null || _this$meshInstance.destroy();
		(_this$sorter = this.sorter) == null || _this$sorter.destroy();
	}
	clone() {
		return new GSplatInstance(this.splat, this.options);
	}
	createMaterial(options) {
		this.material = this.splat.createMaterial(options);
		this.material.setParameter('splatOrder', this.orderTexture);
		if (this.meshInstance) {
			this.meshInstance.material = this.material;
		}
	}
	updateViewport() {
		const device = this.splat.device;
		viewport[0] = device.width;
		viewport[1] = device.height;
		if (this.cameras.length > 0) {
			const camera = this.cameras[0];
			const xr = camera.xr;
			if (xr && xr.active && xr.views.list.length === 2) {
				viewport[0] /= 2;
			}
		}
		this.material.setParameter('viewport', viewport);
	}
	sort(cameraNode) {
		if (this.sorter) {
			const cameraMat = cameraNode.getWorldTransform();
			cameraMat.getTranslation(cameraPosition);
			cameraMat.getZ(cameraDirection);
			const modelMat = this.meshInstance.node.getWorldTransform();
			const invModelMat = mat.invert(modelMat);
			invModelMat.transformPoint(cameraPosition, cameraPosition);
			invModelMat.transformVector(cameraDirection, cameraDirection);
			if (!cameraPosition.equalsApprox(this.lastCameraPosition) || !cameraDirection.equalsApprox(this.lastCameraDirection)) {
				this.lastCameraPosition.copy(cameraPosition);
				this.lastCameraDirection.copy(cameraDirection);
				this.sorter.setCamera(cameraPosition, cameraDirection);
			}
		}
		this.updateViewport();
	}
	update() {
		if (this.cameras.length > 0) {
			const camera = this.cameras[0];
			this.sort(camera._node);
			this.cameras.length = 0;
		}
	}
}

export { GSplatInstance };
