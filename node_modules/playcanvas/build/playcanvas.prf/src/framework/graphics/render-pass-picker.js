import { BlendState } from '../../platform/graphics/blend-state.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { SHADER_PICK } from '../../scene/constants.js';

const tempMeshInstances = [];
const lights = [[], [], []];
class RenderPassPicker extends RenderPass {
	constructor(device, renderer) {
		super(device);
		this.viewBindGroups = [];
		this.renderer = renderer;
	}
	destroy() {
		this.viewBindGroups.forEach(bg => {
			bg.defaultUniformBuffer.destroy();
			bg.destroy();
		});
		this.viewBindGroups.length = 0;
	}
	update(camera, scene, layers, mapping) {
		this.camera = camera;
		this.scene = scene;
		this.layers = layers;
		this.mapping = mapping;
	}
	execute() {
		const device = this.device;
		const {
			renderer,
			camera,
			scene,
			layers,
			mapping,
			renderTarget
		} = this;
		const srcLayers = scene.layers.layerList;
		const subLayerEnabled = scene.layers.subLayerEnabled;
		const isTransparent = scene.layers.subLayerList;
		for (let i = 0; i < srcLayers.length; i++) {
			const srcLayer = srcLayers[i];
			if (layers && layers.indexOf(srcLayer) < 0) {
				continue;
			}
			if (srcLayer.enabled && subLayerEnabled[i]) {
				if (srcLayer.camerasSet.has(camera.camera)) {
					const transparent = isTransparent[i];
					if (srcLayer._clearDepthBuffer) {
						renderer.clear(camera.camera, false, true, false);
					}
					const meshInstances = srcLayer.meshInstances;
					for (let j = 0; j < meshInstances.length; j++) {
						const meshInstance = meshInstances[j];
						if (meshInstance.pick && meshInstance.transparent === transparent) {
							tempMeshInstances.push(meshInstance);
							mapping.set(meshInstance.id, meshInstance);
						}
					}
					if (tempMeshInstances.length > 0) {
						const clusteredLightingEnabled = scene.clusteredLightingEnabled;
						if (clusteredLightingEnabled) {
							const lightClusters = renderer.worldClustersAllocator.empty;
							lightClusters.activate();
						}
						renderer.setCameraUniforms(camera.camera, renderTarget);
						if (device.supportsUniformBuffers) {
							renderer.setupViewUniformBuffers(this.viewBindGroups, renderer.viewUniformFormat, renderer.viewBindGroupFormat, 1);
						}
						renderer.renderForward(camera.camera, renderTarget, tempMeshInstances, lights, SHADER_PICK, meshInstance => {
							device.setBlendState(BlendState.NOBLEND);
						});
						tempMeshInstances.length = 0;
					}
				}
			}
		}
	}
}

export { RenderPassPicker };
