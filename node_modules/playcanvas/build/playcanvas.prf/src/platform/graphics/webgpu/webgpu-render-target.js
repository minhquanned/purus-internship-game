import { StringIds } from '../../../core/string-ids.js';
import { getMultisampledTextureCache } from '../multi-sampled-texture-cache.js';

const stringIds = new StringIds();
class ColorAttachment {
	constructor() {
		this.format = void 0;
		this.multisampledBuffer = void 0;
	}
	destroy() {
		var _this$multisampledBuf;
		(_this$multisampledBuf = this.multisampledBuffer) == null || _this$multisampledBuf.destroy();
		this.multisampledBuffer = null;
	}
}
class DepthAttachment {
	constructor(gpuFormat) {
		this.format = void 0;
		this.hasStencil = void 0;
		this.depthTexture = null;
		this.depthTextureInternal = false;
		this.multisampledDepthBuffer = null;
		this.multisampledDepthBufferKey = void 0;
		this.format = gpuFormat;
		this.hasStencil = gpuFormat === 'depth24plus-stencil8';
	}
	destroy(device) {
		if (this.depthTextureInternal) {
			var _this$depthTexture;
			(_this$depthTexture = this.depthTexture) == null || _this$depthTexture.destroy();
			this.depthTexture = null;
		}
		if (this.multisampledDepthBuffer) {
			this.multisampledDepthBuffer = null;
			getMultisampledTextureCache(device).release(this.multisampledDepthBufferKey);
		}
	}
}
class WebgpuRenderTarget {
	constructor(renderTarget) {
		this.initialized = false;
		this.key = void 0;
		this.colorAttachments = [];
		this.depthAttachment = null;
		this.assignedColorTexture = null;
		this.renderPassDescriptor = {};
		this.isBackbuffer = false;
		this.renderTarget = renderTarget;
	}
	destroy(device) {
		var _this$depthAttachment;
		this.initialized = false;
		this.assignedColorTexture = null;
		this.colorAttachments.forEach(colorAttachment => {
			colorAttachment.destroy();
		});
		this.colorAttachments.length = 0;
		(_this$depthAttachment = this.depthAttachment) == null || _this$depthAttachment.destroy(device);
		this.depthAttachment = null;
	}
	updateKey() {
		const rt = this.renderTarget;
		let key = `${rt.samples}:${this.depthAttachment ? this.depthAttachment.format : 'nodepth'}`;
		this.colorAttachments.forEach(colorAttachment => {
			key += `:${colorAttachment.format}`;
		});
		this.key = stringIds.get(key);
	}
	assignColorTexture(device, gpuTexture) {
		this.assignedColorTexture = gpuTexture;
		const view = gpuTexture.createView({
			format: device.backBufferViewFormat
		});
		const colorAttachment = this.renderPassDescriptor.colorAttachments[0];
		const samples = this.renderTarget.samples;
		if (samples > 1) {
			colorAttachment.resolveTarget = view;
		} else {
			colorAttachment.view = view;
		}
		this.setColorAttachment(0, undefined, device.backBufferViewFormat);
		this.updateKey();
	}
	setColorAttachment(index, multisampledBuffer, format) {
		if (!this.colorAttachments[index]) {
			this.colorAttachments[index] = new ColorAttachment();
		}
		if (multisampledBuffer) {
			this.colorAttachments[index].multisampledBuffer = multisampledBuffer;
		}
		if (format) {
			this.colorAttachments[index].format = format;
		}
	}
	init(device, renderTarget) {
		var _renderTarget$_colorB, _renderTarget$_colorB2;
		const wgpu = device.wgpu;
		this.initDepthStencil(device, wgpu, renderTarget);
		if (renderTarget._colorBuffers) {
			renderTarget._colorBuffers.forEach((colorBuffer, index) => {
				this.setColorAttachment(index, undefined, colorBuffer.impl.format);
			});
		}
		this.renderPassDescriptor.colorAttachments = [];
		const count = this.isBackbuffer ? 1 : (_renderTarget$_colorB = (_renderTarget$_colorB2 = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB2.length) != null ? _renderTarget$_colorB : 0;
		for (let i = 0; i < count; ++i) {
			var _this$colorAttachment;
			const colorAttachment = this.initColor(device, wgpu, renderTarget, i);
			const isDefaultFramebuffer = i === 0 && ((_this$colorAttachment = this.colorAttachments[0]) == null ? void 0 : _this$colorAttachment.format);
			if (colorAttachment.view || isDefaultFramebuffer) {
				this.renderPassDescriptor.colorAttachments.push(colorAttachment);
			}
		}
		this.updateKey();
		this.initialized = true;
	}
	initDepthStencil(device, wgpu, renderTarget) {
		const {
			samples,
			width,
			height,
			depth,
			depthBuffer
		} = renderTarget;
		if (depth || depthBuffer) {
			let renderingView;
			if (!depthBuffer) {
				this.depthAttachment = new DepthAttachment('depth24plus-stencil8');
				const depthTextureDesc = {
					size: [width, height, 1],
					dimension: '2d',
					sampleCount: samples,
					format: this.depthAttachment.format,
					usage: GPUTextureUsage.RENDER_ATTACHMENT
				};
				if (samples > 1) {
					depthTextureDesc.usage |= GPUTextureUsage.TEXTURE_BINDING;
				} else {
					depthTextureDesc.usage |= GPUTextureUsage.COPY_SRC;
				}
				const depthTexture = wgpu.createTexture(depthTextureDesc);
				this.depthAttachment.depthTexture = depthTexture;
				this.depthAttachment.depthTextureInternal = true;
				renderingView = depthTexture.createView();
			} else {
				this.depthAttachment = new DepthAttachment(depthBuffer.impl.format);
				if (samples > 1) {
					const depthFormat = 'depth24plus-stencil8';
					this.depthAttachment.format = depthFormat;
					this.depthAttachment.hasStencil = depthFormat === 'depth24plus-stencil8';
					const key = `${depthBuffer.id}:${width}:${height}:${samples}:${depthFormat}`;
					const msTextures = getMultisampledTextureCache(device);
					let msDepthTexture = msTextures.get(key);
					if (!msDepthTexture) {
						const multisampledDepthDesc = {
							size: [width, height, 1],
							dimension: '2d',
							sampleCount: samples,
							format: depthFormat,
							usage: GPUTextureUsage.RENDER_ATTACHMENT | (depthFormat !== depthBuffer.impl.format ? GPUTextureUsage.TEXTURE_BINDING : 0)
						};
						msDepthTexture = wgpu.createTexture(multisampledDepthDesc);
						msTextures.set(key, msDepthTexture);
					}
					this.depthAttachment.multisampledDepthBuffer = msDepthTexture;
					this.depthAttachment.multisampledDepthBufferKey = key;
					renderingView = msDepthTexture.createView();
				} else {
					const depthTexture = depthBuffer.impl.gpuTexture;
					this.depthAttachment.depthTexture = depthTexture;
					renderingView = depthTexture.createView();
				}
			}
			this.renderPassDescriptor.depthStencilAttachment = {
				view: renderingView
			};
		}
	}
	initColor(device, wgpu, renderTarget, index) {
		const colorAttachment = {};
		const {
			samples,
			width,
			height
		} = renderTarget;
		const colorBuffer = renderTarget.getColorBuffer(index);
		let colorView = null;
		if (colorBuffer) {
			const mipLevelCount = 1;
			if (colorBuffer.cubemap) {
				colorView = colorBuffer.impl.createView({
					dimension: '2d',
					baseArrayLayer: renderTarget.face,
					arrayLayerCount: 1,
					mipLevelCount
				});
			} else {
				colorView = colorBuffer.impl.createView({
					mipLevelCount
				});
			}
		}
		if (samples > 1) {
			const format = this.isBackbuffer ? device.backBufferViewFormat : colorBuffer.impl.format;
			const multisampledTextureDesc = {
				size: [width, height, 1],
				dimension: '2d',
				sampleCount: samples,
				format: format,
				usage: GPUTextureUsage.RENDER_ATTACHMENT
			};
			const multisampledColorBuffer = wgpu.createTexture(multisampledTextureDesc);
			this.setColorAttachment(index, multisampledColorBuffer, multisampledTextureDesc.format);
			colorAttachment.view = multisampledColorBuffer.createView();
			colorAttachment.resolveTarget = colorView;
		} else {
			colorAttachment.view = colorView;
		}
		return colorAttachment;
	}
	setupForRenderPass(renderPass, renderTarget) {
		var _this$renderPassDescr, _this$renderPassDescr2;
		const count = (_this$renderPassDescr = (_this$renderPassDescr2 = this.renderPassDescriptor.colorAttachments) == null ? void 0 : _this$renderPassDescr2.length) != null ? _this$renderPassDescr : 0;
		for (let i = 0; i < count; ++i) {
			const colorAttachment = this.renderPassDescriptor.colorAttachments[i];
			const colorOps = renderPass.colorArrayOps[i];
			const srgb = renderTarget.isColorBufferSrgb(i);
			colorAttachment.clearValue = srgb ? colorOps.clearValueLinear : colorOps.clearValue;
			colorAttachment.loadOp = colorOps.clear ? 'clear' : 'load';
			colorAttachment.storeOp = colorOps.store ? 'store' : 'discard';
		}
		const depthAttachment = this.renderPassDescriptor.depthStencilAttachment;
		if (depthAttachment) {
			depthAttachment.depthClearValue = renderPass.depthStencilOps.clearDepthValue;
			depthAttachment.depthLoadOp = renderPass.depthStencilOps.clearDepth ? 'clear' : 'load';
			depthAttachment.depthStoreOp = renderPass.depthStencilOps.storeDepth ? 'store' : 'discard';
			depthAttachment.depthReadOnly = false;
			if (this.depthAttachment.hasStencil) {
				depthAttachment.stencilClearValue = renderPass.depthStencilOps.clearStencilValue;
				depthAttachment.stencilLoadOp = renderPass.depthStencilOps.clearStencil ? 'clear' : 'load';
				depthAttachment.stencilStoreOp = renderPass.depthStencilOps.storeStencil ? 'store' : 'discard';
				depthAttachment.stencilReadOnly = false;
			}
		}
	}
	loseContext() {
		this.initialized = false;
	}
	resolve(device, target, color, depth) {}
}

export { WebgpuRenderTarget };
