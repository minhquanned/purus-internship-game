export class WebgpuGraphicsDevice extends GraphicsDevice {
    constructor(canvas: any, options?: {});
    /**
     * Object responsible for caching and creation of render pipelines.
     */
    renderPipeline: WebgpuRenderPipeline;
    /**
     * Object responsible for caching and creation of compute pipelines.
     */
    computePipeline: WebgpuComputePipeline;
    /**
     * Object responsible for clearing the rendering surface by rendering a quad.
     *
     * @type { WebgpuClearRenderer }
     */
    clearRenderer: WebgpuClearRenderer;
    /**
     * Object responsible for mipmap generation.
     *
     * @type { WebgpuMipmapRenderer }
     */
    mipmapRenderer: WebgpuMipmapRenderer;
    /**
     * Render pipeline currently set on the device.
     *
     * @type {GPURenderPipeline}
     * @private
     */
    private pipeline;
    /**
     * An array of bind group formats, based on currently assigned bind groups
     *
     * @type {WebgpuBindGroupFormat[]}
     */
    bindGroupFormats: WebgpuBindGroupFormat[];
    /**
     * An empty bind group, used when the draw call is using a typical bind group layout based on
     * BINDGROUP_*** constants but some bind groups are not needed, for example clear renderer.
     *
     * @type {BindGroup}
     */
    emptyBindGroup: BindGroup;
    /**
     * Current command buffer encoder.
     *
     * @type {GPUCommandEncoder|null}
     * @private
     */
    private commandEncoder;
    /**
     * Command buffers scheduled for execution on the GPU.
     *
     * @type {GPUCommandBuffer[]}
     * @private
     */
    private commandBuffers;
    /**
     * @type {GPUSupportedLimits}
     * @private
     */
    private limits;
    backBufferAntialias: any;
    isWebGPU: boolean;
    _deviceType: string;
    resolver: WebgpuResolver;
    initDeviceCaps(): void;
    maxPrecision: string;
    maxSamples: number;
    maxTextures: number;
    fragmentUniformsCount: number;
    vertexUniformsCount: number;
    supportsAreaLights: boolean;
    supportsGpuParticles: boolean;
    supportsImageBitmap: boolean;
    initWebGpu(glslangUrl: any, twgslUrl: any): Promise<this>;
    twgsl: any;
    glslang: any;
    /**
     * @type {GPUAdapter}
     * @private
     */
    private gpuAdapter;
    extCompressedTextureS3TC: any;
    extCompressedTextureETC: any;
    extCompressedTextureASTC: any;
    supportsTimestampQuery: any;
    supportsDepthClip: any;
    supportsDepth32Stencil: any;
    supportsIndirectFirstInstance: any;
    supportsShaderF16: any;
    supportsStorageRGBA8: any;
    /**
     * @type {GPUDevice}
     * @private
     */
    private wgpu;
    gpuContext: RenderingContext;
    backBufferViewFormat: any;
    /**
     * Configuration of the main colorframebuffer we obtain using getCurrentTexture
     *
     * @type {GPUCanvasConfiguration}
     * @private
     */
    private canvasConfig;
    createBackbuffer(): void;
    createBufferImpl(usageFlags: any): WebgpuBuffer;
    createUniformBufferImpl(uniformBuffer: any): WebgpuUniformBuffer;
    createVertexBufferImpl(vertexBuffer: any, format: any, options: any): WebgpuVertexBuffer;
    createIndexBufferImpl(indexBuffer: any, options: any): WebgpuIndexBuffer;
    createShaderImpl(shader: any): WebgpuShader;
    createTextureImpl(texture: any): WebgpuTexture;
    createRenderTargetImpl(renderTarget: any): WebgpuRenderTarget;
    createBindGroupFormatImpl(bindGroupFormat: any): WebgpuBindGroupFormat;
    createBindGroupImpl(bindGroup: any): WebgpuBindGroup;
    createComputeImpl(compute: any): WebgpuCompute;
    /**
     * @param {number} index - Index of the bind group slot
     * @param {BindGroup} bindGroup - Bind group to attach
     * @param {number[]} [offsets] - Byte offsets for all uniform buffers in the bind group.
     */
    setBindGroup(index: number, bindGroup: BindGroup, offsets?: number[]): void;
    submitVertexBuffer(vertexBuffer: any, slot: any): any;
    validateVBLocations(vb0: any, vb1: any): void;
    draw(primitive: any, numInstances: number, keepBuffers: any): void;
    setShader(shader: any, asyncCompile?: boolean): void;
    setBlendState(blendState: any): void;
    setDepthState(depthState: any): void;
    setStencilState(stencilFront: any, stencilBack: any): void;
    stencilRef: any;
    setBlendColor(r: any, g: any, b: any, a: any): void;
    setCullMode(cullMode: any): void;
    setAlphaToCoverage(state: any): void;
    /**
     * Set up default values for the render pass encoder.
     */
    setupPassEncoderDefaults(): void;
    _uploadDirtyTextures(): void;
    /**
     * Start a render pass.
     *
     * @param {RenderPass} renderPass - The render pass to start.
     * @ignore
     */
    startRenderPass(renderPass: RenderPass): void;
    passEncoder: any;
    /**
     * End a render pass.
     *
     * @param {RenderPass} renderPass - The render pass to end.
     * @ignore
     */
    endRenderPass(renderPass: RenderPass): void;
    computeDispatch(computes: any): void;
    addCommandBuffer(commandBuffer: any, front?: boolean): void;
    submit(): void;
    clear(options: any): void;
    setViewport(x: any, y: any, w: any, h: any): void;
    setScissor(x: any, y: any, w: any, h: any): void;
    /**
     * Clear the content of a storage buffer to 0.
     *
     * @param {WebgpuBuffer} storageBuffer - The storage buffer.
     * @param {number} [offset] - The offset of data to clear. Defaults to 0.
     * @param {number} [size] - The size of data to clear. Defaults to the full size of the buffer.
     * @ignore
     */
    clearStorageBuffer(storageBuffer: WebgpuBuffer, offset?: number, size?: number): void;
    /**
     * Read a content of a storage buffer.
     *
     * @param {WebgpuBuffer} storageBuffer - The storage buffer.
     * @param {number} [offset] - The byte offset of data to read. Defaults to 0.
     * @param {number} [size] - The byte size of data to read. Defaults to the full size of the
     * buffer minus the offset.
     * @param {ArrayBufferView} [data] - Typed array to populate with the data read from the storage
     * buffer. When typed array is supplied, enough space needs to be reserved, otherwise only
     * partial data is copied. If not specified, the data is returned in an Uint8Array. Defaults to
     * null.
     * @param {boolean} [immediate] - If true, the read operation will be executed as soon as
     * possible. This has a performance impact, so it should be used only when necessary. Defaults
     * to false.
     * @returns {Promise<ArrayBufferView>} A promise that resolves with the data read from the storage
     * buffer.
     * @ignore
     */
    readStorageBuffer(storageBuffer: WebgpuBuffer, offset?: number, size?: number, data?: ArrayBufferView, immediate?: boolean): Promise<ArrayBufferView>;
    readBuffer(stagingBuffer: any, size: any, data?: any, immediate?: boolean): Promise<any>;
    /**
     * Issues a write operation of the provided data into a storage buffer.
     *
     * @param {WebgpuBuffer} storageBuffer - The storage buffer.
     * @param {number} bufferOffset - The offset in bytes to start writing to the storage buffer.
     * @param {ArrayBufferView} data - The data to write to the storage buffer.
     * @param {number} dataOffset - Offset in data to begin writing from. Given in elements if data
     * is a TypedArray and bytes otherwise.
     * @param {number} size - Size of content to write from data to buffer. Given in elements if
     * data is a TypedArray and bytes otherwise.
     */
    writeStorageBuffer(storageBuffer: WebgpuBuffer, bufferOffset: number, data: ArrayBufferView, dataOffset: number, size: number): void;
    /**
     * Copies source render target into destination render target. Mostly used by post-effects.
     *
     * @param {RenderTarget} [source] - The source render target. Defaults to frame buffer.
     * @param {RenderTarget} [dest] - The destination render target. Defaults to frame buffer.
     * @param {boolean} [color] - If true, will copy the color buffer. Defaults to false.
     * @param {boolean} [depth] - If true, will copy the depth buffer. Defaults to false.
     * @returns {boolean} True if the copy was successful, false otherwise.
     */
    copyRenderTarget(source?: RenderTarget, dest?: RenderTarget, color?: boolean, depth?: boolean): boolean;
    pushMarker(name: any): void;
    popMarker(): void;
}
import { GraphicsDevice } from '../graphics-device.js';
import { WebgpuRenderPipeline } from './webgpu-render-pipeline.js';
import { WebgpuComputePipeline } from './webgpu-compute-pipeline.js';
import { WebgpuClearRenderer } from './webgpu-clear-renderer.js';
import { WebgpuMipmapRenderer } from './webgpu-mipmap-renderer.js';
import { WebgpuBindGroupFormat } from './webgpu-bind-group-format.js';
import { BindGroup } from '../bind-group.js';
import { WebgpuResolver } from './webgpu-resolver.js';
import { WebgpuBuffer } from './webgpu-buffer.js';
import { WebgpuUniformBuffer } from './webgpu-uniform-buffer.js';
import { WebgpuVertexBuffer } from './webgpu-vertex-buffer.js';
import { WebgpuIndexBuffer } from './webgpu-index-buffer.js';
import { WebgpuShader } from './webgpu-shader.js';
import { WebgpuTexture } from './webgpu-texture.js';
import { WebgpuRenderTarget } from './webgpu-render-target.js';
import { WebgpuBindGroup } from './webgpu-bind-group.js';
import { WebgpuCompute } from './webgpu-compute.js';
import type { RenderPass } from '../render-pass.js';
import { RenderTarget } from '../render-target.js';
