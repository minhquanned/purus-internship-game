/**
 * Ignores the integer part of texture coordinates, using only the fractional part.
 *
 * @type {number}
 * @category Graphics
 */
export const ADDRESS_REPEAT: number;
/**
 * Clamps texture coordinate to the range 0 to 1.
 *
 * @type {number}
 * @category Graphics
 */
export const ADDRESS_CLAMP_TO_EDGE: number;
/**
 * Texture coordinate to be set to the fractional part if the integer part is even. If the integer
 * part is odd, then the texture coordinate is set to 1 minus the fractional part.
 *
 * @type {number}
 * @category Graphics
 */
export const ADDRESS_MIRRORED_REPEAT: number;
/**
 * Multiply all fragment components by zero.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_ZERO: number;
/**
 * Multiply all fragment components by one.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_ONE: number;
/**
 * Multiply all fragment components by the components of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_SRC_COLOR: number;
/**
 * Multiply all fragment components by one minus the components of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_ONE_MINUS_SRC_COLOR: number;
/**
 * Multiply all fragment components by the components of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_DST_COLOR: number;
/**
 * Multiply all fragment components by one minus the components of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_ONE_MINUS_DST_COLOR: number;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_SRC_ALPHA: number;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_SRC_ALPHA_SATURATE: number;
/**
 * Multiply all fragment components by one minus the alpha value of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_ONE_MINUS_SRC_ALPHA: number;
/**
 * Multiply all fragment components by the alpha value of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_DST_ALPHA: number;
/**
 * Multiply all fragment components by one minus the alpha value of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_ONE_MINUS_DST_ALPHA: number;
/**
 * Multiplies all fragment components by a constant.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_CONSTANT: number;
/**
 * Multiplies all fragment components by 1 minus a constant.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDMODE_ONE_MINUS_CONSTANT: number;
/**
 * Add the results of the source and destination fragment multiplies.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDEQUATION_ADD: number;
/**
 * Subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDEQUATION_SUBTRACT: number;
/**
 * Reverse and subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDEQUATION_REVERSE_SUBTRACT: number;
/**
 * Use the smallest value.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDEQUATION_MIN: number;
/**
 * Use the largest value.
 *
 * @type {number}
 * @category Graphics
 */
export const BLENDEQUATION_MAX: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to make it available for read
 * access by CPU.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFERUSAGE_READ: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to make it available for write
 * access by CPU.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFERUSAGE_WRITE: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as a source of a copy operation.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFERUSAGE_COPY_SRC: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as a destination of a copy operation, or as a target of a write operation.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFERUSAGE_COPY_DST: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as an index buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFERUSAGE_INDEX: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as a vertex buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFERUSAGE_VERTEX: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as an uniform buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFERUSAGE_UNIFORM: number;
/**
 * An internal flag utilized during the construction of a {@link StorageBuffer} to ensure its
 * compatibility when used as a storage buffer.
 * This flag is hidden as it's automatically used by the StorageBuffer constructor.
 *
 * @type {number}
 * @category Graphics
 * @ignore
 */
export const BUFFERUSAGE_STORAGE: number;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to allow it to store indirect
 * command arguments.
 * TODO: This flag is hidden till the feature is implemented.
 *
 * @type {number}
 * @category Graphics
 * @ignore
 */
export const BUFFERUSAGE_INDIRECT: number;
/**
 * The data store contents will be modified once and used many times.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFER_STATIC: number;
/**
 * The data store contents will be modified repeatedly and used many times.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFER_DYNAMIC: number;
/**
 * The data store contents will be modified once and used at most a few times.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFER_STREAM: number;
/**
 * The data store contents will be modified repeatedly on the GPU and used many times. Optimal for
 * transform feedback usage.
 *
 * @type {number}
 * @category Graphics
 */
export const BUFFER_GPUDYNAMIC: number;
/**
 * Clear the color buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const CLEARFLAG_COLOR: number;
/**
 * Clear the depth buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const CLEARFLAG_DEPTH: number;
/**
 * Clear the stencil buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const CLEARFLAG_STENCIL: number;
/**
 * The positive X face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEFACE_POSX: number;
/**
 * The negative X face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEFACE_NEGX: number;
/**
 * The positive Y face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEFACE_POSY: number;
/**
 * The negative Y face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEFACE_NEGY: number;
/**
 * The positive Z face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEFACE_POSZ: number;
/**
 * The negative Z face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEFACE_NEGZ: number;
/**
 * No triangles are culled.
 *
 * @type {number}
 * @category Graphics
 */
export const CULLFACE_NONE: number;
/**
 * Triangles facing away from the view direction are culled.
 *
 * @type {number}
 * @category Graphics
 */
export const CULLFACE_BACK: number;
/**
 * Triangles facing the view direction are culled.
 *
 * @type {number}
 * @category Graphics
 */
export const CULLFACE_FRONT: number;
/**
 * Triangles are culled regardless of their orientation with respect to the view direction. Note
 * that point or line primitives are unaffected by this render state.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */
export const CULLFACE_FRONTANDBACK: number;
/**
 * Point sample filtering.
 *
 * @type {number}
 * @category Graphics
 */
export const FILTER_NEAREST: number;
/**
 * Bilinear filtering.
 *
 * @type {number}
 * @category Graphics
 */
export const FILTER_LINEAR: number;
/**
 * Use the nearest neighbor in the nearest mipmap level.
 *
 * @type {number}
 * @category Graphics
 */
export const FILTER_NEAREST_MIPMAP_NEAREST: number;
/**
 * Linearly interpolate in the nearest mipmap level.
 *
 * @type {number}
 * @category Graphics
 */
export const FILTER_NEAREST_MIPMAP_LINEAR: number;
/**
 * Use the nearest neighbor after linearly interpolating between mipmap levels.
 *
 * @type {number}
 * @category Graphics
 */
export const FILTER_LINEAR_MIPMAP_NEAREST: number;
/**
 * Linearly interpolate both the mipmap levels and between texels.
 *
 * @type {number}
 * @category Graphics
 */
export const FILTER_LINEAR_MIPMAP_LINEAR: number;
/**
 * Never pass.
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_NEVER: number;
/**
 * Pass if (ref & mask) < (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_LESS: number;
/**
 * Pass if (ref & mask) == (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_EQUAL: number;
/**
 * Pass if (ref & mask) <= (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_LESSEQUAL: number;
/**
 * Pass if (ref & mask) > (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_GREATER: number;
/**
 * Pass if (ref & mask) != (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_NOTEQUAL: number;
/**
 * Pass if (ref & mask) >= (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_GREATEREQUAL: number;
/**
 * Always pass.
 *
 * @type {number}
 * @category Graphics
 */
export const FUNC_ALWAYS: number;
/**
 * 8-bit unsigned vertex indices (0 to 255).
 *
 * @type {number}
 * @category Graphics
 */
export const INDEXFORMAT_UINT8: number;
/**
 * 16-bit unsigned vertex indices (0 to 65,535).
 *
 * @type {number}
 * @category Graphics
 */
export const INDEXFORMAT_UINT16: number;
/**
 * 32-bit unsigned vertex indices (0 to 4,294,967,295).
 *
 * @type {number}
 * @category Graphics
 */
export const INDEXFORMAT_UINT32: number;
export const PIXELFORMAT_A8: 0;
export const PIXELFORMAT_L8: 1;
export const PIXELFORMAT_LA8: 2;
/**
 * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGB565: number;
/**
 * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA5551: number;
/**
 * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA4: number;
/**
 * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGB8: number;
/**
 * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA8: number;
/**
 * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit
 * RGB 5:6:5 color values and a 4x4 two bit lookup table.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DXT1: number;
/**
 * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128
 * bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by
 * 64 bits of color data; encoded the same way as DXT1.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DXT3: number;
/**
 * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits
 * of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits
 * of color data (encoded the same way as DXT1).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DXT5: number;
/**
 * 16-bit floating point RGB (16-bit float for each red, green and blue channels).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGB16F: number;
/**
 * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA16F: number;
/**
 * 32-bit floating point RGB (32-bit float for each red, green and blue channels).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGB32F: number;
/**
 * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA32F: number;
/**
 * 32-bit floating point single channel format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R32F: number;
/**
 * A readable depth buffer format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DEPTH: number;
/**
 * A readable depth/stencil buffer format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DEPTHSTENCIL: number;
/**
 * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the
 * blue channel.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_111110F: number;
/**
 * Color-only sRGB format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_SRGB8: number;
/**
 * Color sRGB format with additional alpha channel.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_SRGBA8: number;
/**
 * ETC1 compressed format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ETC1: number;
/**
 * ETC2 (RGB) compressed format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ETC2_RGB: number;
/**
 * ETC2 (RGBA) compressed format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ETC2_RGBA: number;
/**
 * PVRTC (2BPP RGB) compressed format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_2BPP_RGB_1: number;
/**
 * PVRTC (2BPP RGBA) compressed format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_2BPP_RGBA_1: number;
/**
 * PVRTC (4BPP RGB) compressed format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_4BPP_RGB_1: number;
/**
 * PVRTC (4BPP RGBA) compressed format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_4BPP_RGBA_1: number;
/**
 * ATC compressed format with alpha channel in blocks of 4x4.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ASTC_4x4: number;
/**
 * ATC compressed format with no alpha channel.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ATC_RGB: number;
/**
 * ATC compressed format with alpha channel.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ATC_RGBA: number;
/**
 * 32-bit BGRA (8-bits for blue channel, 8 for green, 8 for red with 8-bit alpha). This is an
 * internal format used by the WebGPU's backbuffer only.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */
export const PIXELFORMAT_BGRA8: number;
/**
 * 8-bit signed integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R8I: number;
/**
 * 8-bit unsigned integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R8U: number;
/**
 * 16-bit signed integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R16I: number;
/**
 * 16-bit unsigned integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R16U: number;
/**
 * 32-bit signed integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R32I: number;
/**
 * 32-bit unsigned integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R32U: number;
/**
 * 8-bit per-channel signed integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG8I: number;
/**
 * 8-bit per-channel unsigned integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG8U: number;
/**
 * 16-bit per-channel signed integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG16I: number;
/**
 * 16-bit per-channel unsigned integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG16U: number;
/**
 * 32-bit per-channel signed integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG32I: number;
/**
 * 32-bit per-channel unsigned integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG32U: number;
/**
 * 8-bit per-channel signed integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA8I: number;
/**
 * 8-bit per-channel unsigned integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA8U: number;
/**
 * 16-bit per-channel signed integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA16I: number;
/**
 * 16-bit per-channel unsigned integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA16U: number;
/**
 * 32-bit per-channel signed integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA32I: number;
/**
 * 32-bit per-channel unsigned integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RGBA32U: number;
/**
 * 16-bit floating point R (16-bit float for red channel).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R16F: number;
/**
 * 16-bit floating point RG (16-bit float for each red and green channels).
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG16F: number;
/**
 * 8-bit per-channel unsigned integer (R) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_R8: number;
/**
 * 8-bit per-channel unsigned integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_RG8: number;
/**
 * Format equivalent to {@link PIXELFORMAT_DXT1} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DXT1_SRGB: number;
/**
 * Format equivalent to {@link PIXELFORMAT_DXT3} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DXT3_SRGBA: number;
/**
 * Format equivalent to {@link PIXELFORMAT_DXT5} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_DXT5_SRGBA: number;
/**
 * Format equivalent to {@link PIXELFORMAT_PVRTC_2BPP_RGB_1} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_2BPP_SRGB_1: number;
/**
 * Format equivalent to {@link PIXELFORMAT_PVRTC_2BPP_RGBA_1} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_2BPP_SRGBA_1: number;
/**
 * Format equivalent to {@link PIXELFORMAT_PVRTC_4BPP_RGB_1} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_4BPP_SRGB_1: number;
/**
 * Format equivalent to {@link PIXELFORMAT_PVRTC_4BPP_RGBA_1} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_PVRTC_4BPP_SRGBA_1: number;
/**
 * Format equivalent to {@link PIXELFORMAT_ETC2_RGB} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ETC2_SRGB: number;
/**
 * Format equivalent to {@link PIXELFORMAT_ETC2_RGBA} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ETC2_SRGBA: number;
/**
 * Format equivalent to {@link PIXELFORMAT_ASTC_4x4} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_ASTC_4x4_SRGB: number;
/**
 * 32-bit BGRA sRGB format. This is an internal format used by the WebGPU's backbuffer only.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */
export const PIXELFORMAT_SBGRA8: number;
/**
 * Compressed high dynamic range signed floating point format storing RGB values.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_BC6F: number;
/**
 * Compressed high dynamic range unsigned floating point format storing RGB values.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_BC6UF: number;
/**
 * Compressed 8-bit fixed-point data. Each 4x4 block of texels consists of 128 bits of RGBA data.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_BC7: number;
/**
 * Compressed 8-bit fixed-point data. Each 4x4 block of texels consists of 128 bits of SRGB_ALPHA
 * data.
 *
 * @type {number}
 * @category Graphics
 */
export const PIXELFORMAT_BC7_SRGBA: number;
/**
 * Information about pixel formats.
 *
 * ldr: whether the format is low dynamic range (LDR), which typically means it's not HDR, and uses
 * sRGB color space to store the color values
 * srgbFormat: the corresponding sRGB format (which automatically converts the sRGB value to linear)
 *
 * @type {Map<number, { name: string, size?: number, blockSize?: number, ldr?: boolean, srgb?: boolean, srgbFormat?: number, isInt?: boolean }>}
 * @ignore
 */
export const pixelFormatInfo: Map<number, {
    name: string;
    size?: number;
    blockSize?: number;
    ldr?: boolean;
    srgb?: boolean;
    srgbFormat?: number;
    isInt?: boolean;
}>;
export function isCompressedPixelFormat(format: any): boolean;
export function isSrgbPixelFormat(format: any): boolean;
export function isIntegerPixelFormat(format: any): boolean;
export function pixelFormatLinearToGamma(format: number): number;
export function requiresManualGamma(format: number): boolean;
export function getPixelFormatArrayType(format: any): Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor;
/**
 * List of distinct points.
 *
 * @type {number}
 * @category Graphics
 */
export const PRIMITIVE_POINTS: number;
/**
 * Discrete list of line segments.
 *
 * @type {number}
 * @category Graphics
 */
export const PRIMITIVE_LINES: number;
/**
 * List of points that are linked sequentially by line segments, with a closing line segment
 * between the last and first points.
 *
 * @type {number}
 * @category Graphics
 */
export const PRIMITIVE_LINELOOP: number;
/**
 * List of points that are linked sequentially by line segments.
 *
 * @type {number}
 * @category Graphics
 */
export const PRIMITIVE_LINESTRIP: number;
/**
 * Discrete list of triangles.
 *
 * @type {number}
 * @category Graphics
 */
export const PRIMITIVE_TRIANGLES: number;
/**
 * Connected strip of triangles where a specified vertex forms a triangle using the previous two.
 *
 * @type {number}
 * @category Graphics
 */
export const PRIMITIVE_TRISTRIP: number;
/**
 * Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.
 *
 * @type {number}
 * @category Graphics
 */
export const PRIMITIVE_TRIFAN: number;
/**
 * Vertex attribute to be treated as a position.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_POSITION: string;
/**
 * Vertex attribute to be treated as a normal.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_NORMAL: string;
/**
 * Vertex attribute to be treated as a tangent.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TANGENT: string;
/**
 * Vertex attribute to be treated as skin blend weights.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_BLENDWEIGHT: string;
/**
 * Vertex attribute to be treated as skin blend indices.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_BLENDINDICES: string;
/**
 * Vertex attribute to be treated as a color.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_COLOR: string;
export const SEMANTIC_TEXCOORD: "TEXCOORD";
/**
 * Vertex attribute to be treated as a texture coordinate (set 0).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD0: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 1).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD1: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 2).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD2: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 3).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD3: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 4).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD4: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 5).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD5: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 6).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD6: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 7).
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_TEXCOORD7: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR0: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR1: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR2: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR3: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR4: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR5: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR6: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR7: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR8: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR9: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR10: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR11: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR12: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR13: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR14: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */
export const SEMANTIC_ATTR15: string;
export const SHADERTAG_MATERIAL: 1;
/**
 * Don't change the stencil buffer value.
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_KEEP: number;
/**
 * Set value to zero.
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_ZERO: number;
/**
 * Replace value with the reference value (see {@link StencilParameters}).
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_REPLACE: number;
/**
 * Increment the value.
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_INCREMENT: number;
/**
 * Increment the value but wrap it to zero when it's larger than a maximum representable value.
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_INCREMENTWRAP: number;
/**
 * Decrement the value.
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_DECREMENT: number;
/**
 * Decrement the value but wrap it to a maximum representable value if the current value is 0.
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_DECREMENTWRAP: number;
/**
 * Invert the value bitwise.
 *
 * @type {number}
 * @category Graphics
 */
export const STENCILOP_INVERT: number;
/**
 * The texture is not in a locked state.
 *
 * @type {number}
 */
export const TEXTURELOCK_NONE: number;
/**
 * Read only. Any changes to the locked mip level's pixels will not update the texture.
 *
 * @type {number}
 * @category Graphics
 */
export const TEXTURELOCK_READ: number;
/**
 * Write only. The contents of the specified mip level will be entirely replaced.
 *
 * @type {number}
 * @category Graphics
 */
export const TEXTURELOCK_WRITE: number;
/**
 * Texture is a default type.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTURETYPE_DEFAULT: string;
/**
 * Texture stores high dynamic range data in RGBM format.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTURETYPE_RGBM: string;
/**
 * Texture stores high dynamic range data in RGBE format.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTURETYPE_RGBE: string;
/**
 * Texture stores high dynamic range data in RGBP encoding.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTURETYPE_RGBP: string;
/**
 * Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal
 * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in
 * higher quality when the texture data is compressed.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTURETYPE_SWIZZLEGGGR: string;
export const TEXHINT_NONE: 0;
export const TEXHINT_SHADOWMAP: 1;
export const TEXHINT_ASSET: 2;
export const TEXHINT_LIGHTMAP: 3;
/**
 * Texture data is stored in a 1-dimensional texture.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREDIMENSION_1D: string;
/**
 * Texture data is stored in a 2-dimensional texture.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREDIMENSION_2D: string;
/**
 * Texture data is stored in an array of 2-dimensional textures.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREDIMENSION_2D_ARRAY: string;
/**
 * Texture data is stored in a cube texture.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREDIMENSION_CUBE: string;
/**
 * Texture data is stored in an array of cube textures.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREDIMENSION_CUBE_ARRAY: string;
/**
 * Texture data is stored in a 3-dimensional texture.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREDIMENSION_3D: string;
/**
 * A sampler type of a texture that contains floating-point data. Typically stored for color
 * textures, where data can be filtered.
 *
 * @type {number}
 * @category Graphics
 */
export const SAMPLETYPE_FLOAT: number;
/**
 * A sampler type of a texture that contains floating-point data, but cannot be filtered. Typically
 * used for textures storing data that cannot be interpolated.
 *
 * @type {number}
 * @category Graphics
 */
export const SAMPLETYPE_UNFILTERABLE_FLOAT: number;
/**
 * A sampler type of a texture that contains depth data. Typically used for depth textures.
 *
 * @type {number}
 * @category Graphics
 */
export const SAMPLETYPE_DEPTH: number;
/**
 * A sampler type of a texture that contains signed integer data.
 *
 * @type {number}
 * @category Graphics
 */
export const SAMPLETYPE_INT: number;
/**
 * A sampler type of a texture that contains unsigned integer data.
 *
 * @type {number}
 * @category Graphics
 */
export const SAMPLETYPE_UINT: number;
/**
 * Texture data is not stored a specific projection format.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREPROJECTION_NONE: string;
/**
 * Texture data is stored in cubemap projection format.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREPROJECTION_CUBE: string;
/**
 * Texture data is stored in equirectangular projection format.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREPROJECTION_EQUIRECT: string;
/**
 * Texture data is stored in octahedral projection format.
 *
 * @type {string}
 * @category Graphics
 */
export const TEXTUREPROJECTION_OCTAHEDRAL: string;
/**
 * Shader source code uses GLSL language.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERLANGUAGE_GLSL: string;
/**
 * Shader source code uses WGSL language.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERLANGUAGE_WGSL: string;
/**
 * Signed byte vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_INT8: number;
/**
 * Unsigned byte vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_UINT8: number;
/**
 * Signed short vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_INT16: number;
/**
 * Unsigned short vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_UINT16: number;
/**
 * Signed integer vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_INT32: number;
/**
 * Unsigned integer vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_UINT32: number;
/**
 * Floating point vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_FLOAT32: number;
/**
 * 16-bit floating point vertex element type.
 *
 * @type {number}
 * @category Graphics
 */
export const TYPE_FLOAT16: number;
/**
 * Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_BOOL: number;
/**
 * Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_INT: number;
/**
 * Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_FLOAT: number;
/**
 * 2 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_VEC2: number;
/**
 * 3 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_VEC3: number;
/**
 * 4 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_VEC4: number;
/**
 * 2 x Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_IVEC2: number;
/**
 * 3 x Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_IVEC3: number;
/**
 * 4 x Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_IVEC4: number;
/**
 * 2 x Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_BVEC2: number;
/**
 * 3 x Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_BVEC3: number;
/**
 * 4 x Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_BVEC4: number;
/**
 * 2 x 2 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_MAT2: number;
/**
 * 3 x 3 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_MAT3: number;
/**
 * 4 x 4 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_MAT4: number;
export const UNIFORMTYPE_TEXTURE2D: 15;
export const UNIFORMTYPE_TEXTURECUBE: 16;
export const UNIFORMTYPE_FLOATARRAY: 17;
export const UNIFORMTYPE_TEXTURE2D_SHADOW: 18;
export const UNIFORMTYPE_TEXTURECUBE_SHADOW: 19;
export const UNIFORMTYPE_TEXTURE3D: 20;
export const UNIFORMTYPE_VEC2ARRAY: 21;
export const UNIFORMTYPE_VEC3ARRAY: 22;
export const UNIFORMTYPE_VEC4ARRAY: 23;
export const UNIFORMTYPE_MAT4ARRAY: 24;
export const UNIFORMTYPE_TEXTURE2D_ARRAY: 25;
/**
 * Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_UINT: number;
/**
 * 2 x Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_UVEC2: number;
/**
 * 3 x Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_UVEC3: number;
/**
 * 4 x Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */
export const UNIFORMTYPE_UVEC4: number;
export const UNIFORMTYPE_INTARRAY: 30;
export const UNIFORMTYPE_UINTARRAY: 31;
export const UNIFORMTYPE_BOOLARRAY: 32;
export const UNIFORMTYPE_IVEC2ARRAY: 33;
export const UNIFORMTYPE_UVEC2ARRAY: 34;
export const UNIFORMTYPE_BVEC2ARRAY: 35;
export const UNIFORMTYPE_IVEC3ARRAY: 36;
export const UNIFORMTYPE_UVEC3ARRAY: 37;
export const UNIFORMTYPE_BVEC3ARRAY: 38;
export const UNIFORMTYPE_IVEC4ARRAY: 39;
export const UNIFORMTYPE_UVEC4ARRAY: 40;
export const UNIFORMTYPE_BVEC4ARRAY: 41;
export const UNIFORMTYPE_ITEXTURE2D: 42;
export const UNIFORMTYPE_UTEXTURE2D: 43;
export const UNIFORMTYPE_ITEXTURECUBE: 44;
export const UNIFORMTYPE_UTEXTURECUBE: 45;
export const UNIFORMTYPE_ITEXTURE3D: 46;
export const UNIFORMTYPE_UTEXTURE3D: 47;
export const UNIFORMTYPE_ITEXTURE2D_ARRAY: 48;
export const UNIFORMTYPE_UTEXTURE2D_ARRAY: 49;
export const uniformTypeToName: string[];
export const uniformTypeToStorage: Uint8Array;
/**
 * A WebGL 2 device type.
 *
 * @type {string}
 * @category Graphics
 */
export const DEVICETYPE_WEBGL2: string;
/**
 * A WebGPU device type.
 *
 * @type {string}
 * @category Graphics
 */
export const DEVICETYPE_WEBGPU: string;
/**
 * A Null device type.
 *
 * @type {string}
 * @category Graphics
 */
export const DEVICETYPE_NULL: string;
/**
 * The resource is visible to the vertex shader.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADERSTAGE_VERTEX: number;
/**
 * The resource is visible to the fragment shader.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADERSTAGE_FRAGMENT: number;
/**
 * The resource is visible to the compute shader.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADERSTAGE_COMPUTE: number;
/**
 * Display format for low dynamic range data. This is always supported; however, due to the cost, it
 * does not implement linear alpha blending on the main framebuffer. Instead, alpha blending occurs
 * in sRGB space.
 *
 * @type {string}
 * @category Graphics
 */
export const DISPLAYFORMAT_LDR: string;
/**
 * Display format for low dynamic range data in the sRGB color space. This format correctly
 * implements linear alpha blending on the main framebuffer, with the alpha blending occurring in
 * linear space. This is currently supported on WebGPU platform only. On unsupported platforms, it
 * silently falls back to {@link DISPLAYFORMAT_LDR}.
 *
 * @type {string}
 * @category Graphics
 */
export const DISPLAYFORMAT_LDR_SRGB: string;
/**
 * Display format for high dynamic range data, using 16bit floating point values.
 * Note: This is supported on WebGPU platform only, and ignored on other platforms. On displays
 * without HDR support, it silently falls back to {@link DISPLAYFORMAT_LDR}. Use
 * {@link GraphicsDevice.isHdr} to see if the HDR format is used. When it is, it's recommended to
 * use {@link TONEMAP_NONE} for the tonemapping mode, to avoid it clipping the high dynamic range.
 *
 * @type {string}
 * @category Graphics
 */
export const DISPLAYFORMAT_HDR: string;
export const TEXPROPERTY_MIN_FILTER: 1;
export const TEXPROPERTY_MAG_FILTER: 2;
export const TEXPROPERTY_ADDRESS_U: 4;
export const TEXPROPERTY_ADDRESS_V: 8;
export const TEXPROPERTY_ADDRESS_W: 16;
export const TEXPROPERTY_COMPARE_ON_READ: 32;
export const TEXPROPERTY_COMPARE_FUNC: 64;
export const TEXPROPERTY_ANISOTROPY: 128;
export const TEXPROPERTY_ALL: 255;
export const BINDGROUP_VIEW: 0;
export const BINDGROUP_MESH: 1;
export const BINDGROUP_MESH_UB: 2;
export const bindGroupNames: string[];
export const UNIFORM_BUFFER_DEFAULT_SLOT_NAME: "default";
export const typedArrayTypes: (Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor)[];
export const typedArrayTypesByteSize: number[];
export const vertexTypesNames: string[];
export namespace typedArrayToType {
    export { TYPE_INT8 as Int8Array };
    export { TYPE_UINT8 as Uint8Array };
    export { TYPE_INT16 as Int16Array };
    export { TYPE_UINT16 as Uint16Array };
    export { TYPE_INT32 as Int32Array };
    export { TYPE_UINT32 as Uint32Array };
    export { TYPE_FLOAT32 as Float32Array };
}
export const typedArrayIndexFormats: (Uint8ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor)[];
export const typedArrayIndexFormatsByteSize: number[];
/**
 * Map of engine semantics into location on device in range 0..15 (note - semantics mapping to the
 * same location cannot be used at the same time) organized in a way that ATTR0-ATTR7 do not
 * overlap with common important semantics.
 *
 * @type {object}
 * @ignore
 * @category Graphics
 */
export const semanticToLocation: object;
/**
 * Chunk API versions
 *
 * @type {string}
 * @category Graphics
 */
export const CHUNKAPI_1_51: string;
export const CHUNKAPI_1_55: "1.55";
export const CHUNKAPI_1_56: "1.56";
export const CHUNKAPI_1_57: "1.57";
export const CHUNKAPI_1_58: "1.58";
export const CHUNKAPI_1_60: "1.60";
export const CHUNKAPI_1_62: "1.62";
export const CHUNKAPI_1_65: "1.65";
export const CHUNKAPI_1_70: "1.70";
export const CHUNKAPI_2_1: "2.1";
