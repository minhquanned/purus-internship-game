/**
 * A camera.
 *
 * @ignore
 */
export class Camera {
    /**
     * @type {ShaderPassInfo|null}
     */
    shaderPassInfo: ShaderPassInfo | null;
    /**
     * @type {RenderPassColorGrab|null}
     */
    renderPassColorGrab: RenderPassColorGrab | null;
    /**
     * @type {RenderPass|null}
     */
    renderPassDepthGrab: RenderPass | null;
    /**
     * The rendering parameters.
     *
     * @type {RenderingParams|null}
     */
    renderingParams: RenderingParams | null;
    /**
     * Render passes used to render this camera. If empty, the camera will render using the default
     * render passes.
     *
     * @type {RenderPass[]}
     */
    renderPasses: RenderPass[];
    /** @type {number} */
    jitter: number;
    _aspectRatio: number;
    _aspectRatioMode: number;
    _calculateProjection: any;
    _calculateTransform: any;
    _clearColor: Color;
    _clearColorBuffer: boolean;
    _clearDepth: number;
    _clearDepthBuffer: boolean;
    _clearStencil: number;
    _clearStencilBuffer: boolean;
    _cullFaces: boolean;
    _farClip: number;
    _flipFaces: boolean;
    _fov: number;
    _frustumCulling: boolean;
    _horizontalFov: boolean;
    _layers: number[];
    _layersSet: Set<number>;
    _nearClip: number;
    _node: any;
    _orthoHeight: number;
    _projection: number;
    _rect: Vec4;
    _renderTarget: any;
    _scissorRect: Vec4;
    _scissorRectClear: boolean;
    _aperture: number;
    _shutter: number;
    _sensitivity: number;
    _projMat: Mat4;
    _projMatDirty: boolean;
    _projMatSkybox: Mat4;
    _viewMat: Mat4;
    _viewMatDirty: boolean;
    _viewProjMat: Mat4;
    _viewProjMatDirty: boolean;
    _shaderMatricesVersion: number;
    _viewProjInverse: Mat4;
    _viewProjCurrent: any;
    _viewProjPrevious: Mat4;
    _jitters: number[];
    frustum: Frustum;
    _xr: any;
    _xrProperties: {
        horizontalFov: boolean;
        fov: number;
        aspectRatio: number;
        farClip: number;
        nearClip: number;
    };
    destroy(): void;
    /**
     * Store camera matrices required by TAA. Only update them once per frame.
     */
    _storeShaderMatrices(viewProjMat: any, jitterX: any, jitterY: any, renderVersion: any): void;
    /**
     * True if the camera clears the full render target. (viewport / scissor are full size)
     */
    get fullSizeClearRect(): boolean;
    set aspectRatio(newValue: number);
    get aspectRatio(): number;
    set aspectRatioMode(newValue: number);
    get aspectRatioMode(): number;
    set calculateProjection(newValue: any);
    get calculateProjection(): any;
    set calculateTransform(newValue: any);
    get calculateTransform(): any;
    set clearColor(newValue: Color);
    get clearColor(): Color;
    set clearColorBuffer(newValue: boolean);
    get clearColorBuffer(): boolean;
    set clearDepth(newValue: number);
    get clearDepth(): number;
    set clearDepthBuffer(newValue: boolean);
    get clearDepthBuffer(): boolean;
    set clearStencil(newValue: number);
    get clearStencil(): number;
    set clearStencilBuffer(newValue: boolean);
    get clearStencilBuffer(): boolean;
    set cullFaces(newValue: boolean);
    get cullFaces(): boolean;
    set farClip(newValue: number);
    get farClip(): number;
    set flipFaces(newValue: boolean);
    get flipFaces(): boolean;
    set fov(newValue: number);
    get fov(): number;
    set frustumCulling(newValue: boolean);
    get frustumCulling(): boolean;
    set horizontalFov(newValue: boolean);
    get horizontalFov(): boolean;
    set layers(newValue: number[]);
    get layers(): number[];
    get layersSet(): Set<number>;
    set nearClip(newValue: number);
    get nearClip(): number;
    set node(newValue: any);
    get node(): any;
    set orthoHeight(newValue: number);
    get orthoHeight(): number;
    set projection(newValue: number);
    get projection(): number;
    get projectionMatrix(): Mat4;
    set rect(newValue: Vec4);
    get rect(): Vec4;
    set renderTarget(newValue: any);
    get renderTarget(): any;
    set scissorRect(newValue: Vec4);
    get scissorRect(): Vec4;
    get viewMatrix(): Mat4;
    set aperture(newValue: number);
    get aperture(): number;
    set sensitivity(newValue: number);
    get sensitivity(): number;
    set shutter(newValue: number);
    get shutter(): number;
    set xr(newValue: any);
    get xr(): any;
    /**
     * Creates a duplicate of the camera.
     *
     * @returns {Camera} A cloned Camera.
     */
    clone(): Camera;
    /**
     * Copies one camera to another.
     *
     * @param {Camera} other - Camera to copy.
     * @returns {Camera} Self for chaining.
     */
    copy(other: Camera): Camera;
    _enableRenderPassColorGrab(device: any, enable: any): void;
    _enableRenderPassDepthGrab(device: any, renderer: any, enable: any): void;
    _updateViewProjMat(): void;
    /**
     * Convert a point from 3D world space to 2D canvas pixel space.
     *
     * @param {Vec3} worldCoord - The world space coordinate to transform.
     * @param {number} cw - The width of PlayCanvas' canvas element.
     * @param {number} ch - The height of PlayCanvas' canvas element.
     * @param {Vec3} [screenCoord] - 3D vector to receive screen coordinate result.
     * @returns {Vec3} The screen space coordinate.
     */
    worldToScreen(worldCoord: Vec3, cw: number, ch: number, screenCoord?: Vec3): Vec3;
    /**
     * Convert a point from 2D canvas pixel space to 3D world space.
     *
     * @param {number} x - X coordinate on PlayCanvas' canvas element.
     * @param {number} y - Y coordinate on PlayCanvas' canvas element.
     * @param {number} z - The distance from the camera in world space to create the new point.
     * @param {number} cw - The width of PlayCanvas' canvas element.
     * @param {number} ch - The height of PlayCanvas' canvas element.
     * @param {Vec3} [worldCoord] - 3D vector to receive world coordinate result.
     * @returns {Vec3} The world space coordinate.
     */
    screenToWorld(x: number, y: number, z: number, cw: number, ch: number, worldCoord?: Vec3): Vec3;
    _evaluateProjectionMatrix(): void;
    getProjectionMatrixSkybox(): Mat4;
    getExposure(): number;
    getScreenSize(sphere: any): number;
    /**
     * Returns an array of corners of the frustum of the camera in the local coordinate system of the camera.
     *
     * @param {number} [near] - Near distance for the frustum points. Defaults to the near clip distance of the camera.
     * @param {number} [far] - Far distance for the frustum points. Defaults to the far clip distance of the camera.
     * @returns {Vec3[]} - An array of corners, using a global storage space.
     */
    getFrustumCorners(near?: number, far?: number): Vec3[];
    /**
     * Sets XR camera properties that should be derived physical camera in {@link XrManager}.
     *
     * @param {object} [properties] - Properties object.
     * @param {number} [properties.aspectRatio] - Aspect ratio.
     * @param {number} [properties.farClip] - Far clip.
     * @param {number} [properties.fov] - Field of view.
     * @param {boolean} [properties.horizontalFov] - Enable horizontal field of view.
     * @param {number} [properties.nearClip] - Near clip.
     */
    setXrProperties(properties?: {
        aspectRatio?: number;
        farClip?: number;
        fov?: number;
        horizontalFov?: boolean;
        nearClip?: number;
    }): void;
}
import type { ShaderPassInfo } from './shader-pass.js';
import { RenderPassColorGrab } from './graphics/render-pass-color-grab.js';
import type { RenderPass } from '../platform/graphics/render-pass.js';
import type { RenderingParams } from './renderer/rendering-params.js';
import { Color } from '../core/math/color.js';
import { Vec4 } from '../core/math/vec4.js';
import { Mat4 } from '../core/math/mat4.js';
import { Frustum } from '../core/shape/frustum.js';
import { Vec3 } from '../core/math/vec3.js';
