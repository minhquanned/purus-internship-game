import { extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { Vec2 } from '../../core/math/vec2.js';
import { Texture } from '../../platform/graphics/texture.js';
import { BoundingBox } from '../../core/shape/bounding-box.js';
import { PIXELFORMAT_RGBA32U, PIXELFORMAT_RGBA32F, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';
import { createGSplatCompressedMaterial } from './gsplat-compressed-material.js';

class GSplatCompressed {
	constructor(device, gsplatData) {
		this.device = void 0;
		this.numSplats = void 0;
		this.aabb = void 0;
		this.centers = void 0;
		this.packedTexture = void 0;
		this.chunkTexture = void 0;
		const numSplats = gsplatData.numSplats;
		const numChunks = Math.ceil(numSplats / 256);
		this.device = device;
		this.numSplats = numSplats;
		this.aabb = new BoundingBox();
		gsplatData.calcAabb(this.aabb);
		this.centers = new Float32Array(gsplatData.numSplats * 3);
		gsplatData.getCenters(this.centers);
		this.packedTexture = this.createTexture('packedData', PIXELFORMAT_RGBA32U, this.evalTextureSize(numSplats), gsplatData.vertexData);
		const chunkSize = this.evalTextureSize(numChunks);
		chunkSize.x *= 3;
		this.chunkTexture = this.createTexture('chunkData', PIXELFORMAT_RGBA32F, chunkSize, gsplatData.chunkData);
	}
	destroy() {
		var _this$packedTexture, _this$chunkTexture;
		(_this$packedTexture = this.packedTexture) == null || _this$packedTexture.destroy();
		(_this$chunkTexture = this.chunkTexture) == null || _this$chunkTexture.destroy();
	}
	createMaterial(options) {
		const result = createGSplatCompressedMaterial(options);
		result.setParameter('packedTexture', this.packedTexture);
		result.setParameter('chunkTexture', this.chunkTexture);
		result.setParameter('tex_params', new Float32Array([this.numSplats, this.packedTexture.width, this.chunkTexture.width / 3, 0]));
		return result;
	}
	evalTextureSize(count) {
		const width = Math.ceil(Math.sqrt(count));
		const height = Math.ceil(count / width);
		return new Vec2(width, height);
	}
	createTexture(name, format, size, data) {
		return new Texture(this.device, _extends({
			name: name,
			width: size.x,
			height: size.y,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		}, data ? {
			levels: [data]
		} : {}));
	}
}

export { GSplatCompressed };
