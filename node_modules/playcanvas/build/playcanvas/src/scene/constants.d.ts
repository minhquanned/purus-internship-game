/**
 * Subtract the color of the source fragment from the destination fragment and write the result to
 * the frame buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_SUBTRACTIVE: number;
/**
 * Add the color of the source fragment to the destination fragment and write the result to the
 * frame buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_ADDITIVE: number;
/**
 * Enable simple translucency for materials such as glass. This is equivalent to enabling a source
 * blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination blend mode of
 * {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_NORMAL: number;
/**
 * Disable blending.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_NONE: number;
/**
 * Similar to {@link BLEND_NORMAL} expect the source fragment is assumed to have already been
 * multiplied by the source alpha value.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_PREMULTIPLIED: number;
/**
 * Multiply the color of the source fragment by the color of the destination fragment and write the
 * result to the frame buffer.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_MULTIPLICATIVE: number;
/**
 * Same as {@link BLEND_ADDITIVE} except the source RGB is multiplied by the source alpha.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_ADDITIVEALPHA: number;
/**
 * Multiplies colors and doubles the result.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_MULTIPLICATIVE2X: number;
/**
 * Softer version of additive.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_SCREEN: number;
/**
 * Minimum color.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_MIN: number;
/**
 * Maximum color.
 *
 * @type {number}
 * @category Graphics
 */
export const BLEND_MAX: number;
/**
 * No fog is applied to the scene.
 *
 * @type {string}
 * @category Graphics
 */
export const FOG_NONE: string;
/**
 * Fog rises linearly from zero to 1 between a start and end depth.
 *
 * @type {string}
 * @category Graphics
 */
export const FOG_LINEAR: string;
/**
 * Fog rises according to an exponential curve controlled by a density value.
 *
 * @type {string}
 * @category Graphics
 */
export const FOG_EXP: string;
/**
 * Fog rises according to an exponential curve controlled by a density value.
 *
 * @type {string}
 * @category Graphics
 */
export const FOG_EXP2: string;
/**
 * No Fresnel.
 *
 * @type {number}
 * @category Graphics
 */
export const FRESNEL_NONE: number;
/**
 * Schlick's approximation of Fresnel.
 *
 * @type {number}
 * @category Graphics
 */
export const FRESNEL_SCHLICK: number;
export const LAYER_HUD: 0;
export const LAYER_GIZMO: 1;
export const LAYER_FX: 2;
export const LAYER_WORLD: 15;
/**
 * The world layer.
 *
 * @type {number}
 * @category Graphics
 */
export const LAYERID_WORLD: number;
/**
 * The depth layer.
 *
 * @type {number}
 * @category Graphics
 */
export const LAYERID_DEPTH: number;
/**
 * The skybox layer.
 *
 * @type {number}
 * @category Graphics
 */
export const LAYERID_SKYBOX: number;
/**
 * The immediate layer.
 *
 * @type {number}
 * @category Graphics
 */
export const LAYERID_IMMEDIATE: number;
/**
 * The UI layer.
 *
 * @type {number}
 * @category Graphics
 */
export const LAYERID_UI: number;
/**
 * Directional (global) light source.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTTYPE_DIRECTIONAL: number;
/**
 * Omni-directional (local) light source.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTTYPE_OMNI: number;
/**
 * Point (local) light source.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */
export const LIGHTTYPE_POINT: number;
/**
 * Spot (local) light source.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTTYPE_SPOT: number;
export const LIGHTTYPE_COUNT: 3;
/**
 * Infinitesimally small point light source shape.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTSHAPE_PUNCTUAL: number;
/**
 * Rectangle shape of light source.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTSHAPE_RECT: number;
/**
 * Disk shape of light source.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTSHAPE_DISK: number;
/**
 * Sphere shape of light source.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTSHAPE_SPHERE: number;
/**
 * Linear distance falloff model for light attenuation.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTFALLOFF_LINEAR: number;
/**
 * Inverse squared distance falloff model for light attenuation.
 *
 * @type {number}
 * @category Graphics
 */
export const LIGHTFALLOFF_INVERSESQUARED: number;
/**
 * Render depth buffer only, can be used for PCF 3x3 sampling.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOW_PCF3: number;
export const SHADOW_DEPTH: 0;
/**
 * Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to
 * work correctly.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOW_VSM8: number;
/**
 * Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls
 * back to {@link SHADOW_VSM8}, if not supported.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOW_VSM16: number;
/**
 * Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back
 * to {@link SHADOW_VSM16}, if not supported.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOW_VSM32: number;
/**
 * Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOW_PCF5: number;
/**
 * Render depth buffer only, can be used for PCF 1x1 sampling.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOW_PCF1: number;
/**
 * Render depth as color for PCSS software filtering.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOW_PCSS: number;
/**
 * map of engine SHADOW__*** to a string representation
 *
 * @type {object}
 * @ignore
 * @category Graphics
 */
export const shadowTypeToString: object;
/**
 * Box filter.
 *
 * @type {number}
 * @category Graphics
 */
export const BLUR_BOX: number;
/**
 * Gaussian filter. May look smoother than box, but requires more samples.
 *
 * @type {number}
 * @category Graphics
 */
export const BLUR_GAUSSIAN: number;
/**
 * No sorting, particles are drawn in arbitrary order. Can be simulated on GPU.
 *
 * @type {number}
 * @category Graphics
 */
export const PARTICLESORT_NONE: number;
/**
 * Sorting based on distance to the camera. CPU only.
 *
 * @type {number}
 * @category Graphics
 */
export const PARTICLESORT_DISTANCE: number;
/**
 * Newer particles are drawn first. CPU only.
 *
 * @type {number}
 * @category Graphics
 */
export const PARTICLESORT_NEWER_FIRST: number;
/**
 * Older particles are drawn first. CPU only.
 *
 * @type {number}
 * @category Graphics
 */
export const PARTICLESORT_OLDER_FIRST: number;
export const PARTICLEMODE_GPU: 0;
export const PARTICLEMODE_CPU: 1;
/**
 * Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.
 *
 * @type {number}
 * @category Graphics
 */
export const EMITTERSHAPE_BOX: number;
/**
 * Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the
 * center.
 *
 * @type {number}
 * @category Graphics
 */
export const EMITTERSHAPE_SPHERE: number;
/**
 * Particles are facing camera.
 *
 * @type {number}
 * @category Graphics
 */
export const PARTICLEORIENTATION_SCREEN: number;
/**
 * User defines world space normal (particleNormal) to set planes orientation.
 *
 * @type {number}
 * @category Graphics
 */
export const PARTICLEORIENTATION_WORLD: number;
/**
 * Similar to previous, but the normal is affected by emitter(entity) transformation.
 *
 * @type {number}
 * @category Graphics
 */
export const PARTICLEORIENTATION_EMITTER: number;
/**
 * A perspective camera projection where the frustum shape is essentially pyramidal.
 *
 * @type {number}
 * @category Graphics
 */
export const PROJECTION_PERSPECTIVE: number;
/**
 * An orthographic camera projection where the frustum shape is essentially a cuboid.
 *
 * @type {number}
 * @category Graphics
 */
export const PROJECTION_ORTHOGRAPHIC: number;
/**
 * Render mesh instance as solid geometry.
 *
 * @type {number}
 * @category Graphics
 */
export const RENDERSTYLE_SOLID: number;
/**
 * Render mesh instance as wireframe.
 *
 * @type {number}
 * @category Graphics
 */
export const RENDERSTYLE_WIREFRAME: number;
/**
 * Render mesh instance as points.
 *
 * @type {number}
 * @category Graphics
 */
export const RENDERSTYLE_POINTS: number;
/**
 * The cube map is treated as if it is infinitely far away.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEPROJ_NONE: number;
/**
 * The cube map is box-projected based on a world space axis-aligned bounding box.
 *
 * @type {number}
 * @category Graphics
 */
export const CUBEPROJ_BOX: number;
/**
 * Multiply together the primary and secondary colors.
 *
 * @type {string}
 * @category Graphics
 */
export const DETAILMODE_MUL: string;
/**
 * Add together the primary and secondary colors.
 *
 * @type {string}
 * @category Graphics
 */
export const DETAILMODE_ADD: string;
/**
 * Softer version of {@link DETAILMODE_ADD}.
 *
 * @type {string}
 * @category Graphics
 */
export const DETAILMODE_SCREEN: string;
/**
 * Multiplies or screens the colors, depending on the primary color.
 *
 * @type {string}
 * @category Graphics
 */
export const DETAILMODE_OVERLAY: string;
/**
 * Select whichever of the primary and secondary colors is darker, component-wise.
 *
 * @type {string}
 * @category Graphics
 */
export const DETAILMODE_MIN: string;
/**
 * Select whichever of the primary and secondary colors is lighter, component-wise.
 *
 * @type {string}
 * @category Graphics
 */
export const DETAILMODE_MAX: string;
/**
 * No gamma correction.
 *
 * @type {number}
 * @category Graphics
 */
export const GAMMA_NONE: number;
/**
 * Apply sRGB gamma correction.
 *
 * @type {number}
 * @category Graphics
 */
export const GAMMA_SRGB: number;
/**
 * Linear tonemapping. The colors are preserved, but the exposure is applied.
 *
 * @type {number}
 * @category Graphics
 */
export const TONEMAP_LINEAR: number;
/**
 * Filmic tonemapping curve.
 *
 * @type {number}
 * @category Graphics
 */
export const TONEMAP_FILMIC: number;
/**
 * Hejl filmic tonemapping curve.
 *
 * @type {number}
 * @category Graphics
 */
export const TONEMAP_HEJL: number;
/**
 * ACES filmic tonemapping curve.
 *
 * @type {number}
 * @category Graphics
 */
export const TONEMAP_ACES: number;
/**
 * ACES v2 filmic tonemapping curve.
 *
 * @type {number}
 * @category Graphics
 */
export const TONEMAP_ACES2: number;
/**
 * Khronos PBR Neutral tonemapping curve.
 *
 * @type {number}
 * @category Graphics
 */
export const TONEMAP_NEUTRAL: number;
/**
 * No tonemapping or exposure is applied. Used for HDR rendering.
 *
 * @type {number}
 * @category Graphics
 */
export const TONEMAP_NONE: number;
/**
 * No specular occlusion.
 *
 * @type {number}
 * @category Graphics
 */
export const SPECOCC_NONE: number;
/**
 * Use AO directly to occlude specular.
 *
 * @type {number}
 * @category Graphics
 */
export const SPECOCC_AO: number;
/**
 * Modify AO based on material glossiness/view angle to occlude specular.
 *
 * @type {number}
 * @category Graphics
 */
export const SPECOCC_GLOSSDEPENDENT: number;
export const SHADERDEF_NOSHADOW: 1;
export const SHADERDEF_SKIN: 2;
export const SHADERDEF_UV0: 4;
export const SHADERDEF_UV1: 8;
export const SHADERDEF_VCOLOR: 16;
export const SHADERDEF_INSTANCING: 32;
export const SHADERDEF_LM: 64;
export const SHADERDEF_DIRLM: 128;
export const SHADERDEF_SCREENSPACE: 256;
export const SHADERDEF_TANGENTS: 512;
export const SHADERDEF_MORPH_POSITION: 1024;
export const SHADERDEF_MORPH_NORMAL: 2048;
export const SHADERDEF_LMAMBIENT: 4096;
export const SHADERDEF_MORPH_TEXTURE_BASED_INT: 8192;
export const SHADERDEF_BATCH: 16384;
/**
 * The shadow map is not to be updated.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOWUPDATE_NONE: number;
/**
 * The shadow map is regenerated this frame and not on subsequent frames.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOWUPDATE_THISFRAME: number;
/**
 * The shadow map is regenerated every frame.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADOWUPDATE_REALTIME: number;
export const SORTKEY_FORWARD: 0;
export const SORTKEY_DEPTH: 1;
export const MASK_AFFECT_DYNAMIC: 1;
export const MASK_AFFECT_LIGHTMAPPED: 2;
export const MASK_BAKE: 4;
/**
 * Render shaded materials using forward rendering.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADER_FORWARD: number;
export const SHADER_PREPASS_VELOCITY: 1;
/**
 * Render RGBA-encoded depth value.
 *
 * @type {number}
 * @category Graphics
 */
export const SHADER_DEPTH: number;
export const SHADER_PICK: 3;
export const SHADER_SHADOW: 4;
/**
 * Shader that performs forward rendering.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_FORWARD: string;
/**
 * Shader used for debug rendering of albedo.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_ALBEDO: string;
/**
 * Shader used for debug rendering of world normal.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_WORLDNORMAL: string;
/**
 * Shader used for debug rendering of opacity.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_OPACITY: string;
/**
 * Shader used for debug rendering of specularity.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_SPECULARITY: string;
/**
 * Shader used for debug rendering of gloss.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_GLOSS: string;
/**
 * Shader used for debug rendering of metalness.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_METALNESS: string;
/**
 * Shader used for debug rendering of ao.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_AO: string;
/**
 * Shader used for debug rendering of emission.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_EMISSION: string;
/**
 * Shader used for debug rendering of lighting.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_LIGHTING: string;
/**
 * Shader used for debug rendering of UV0 texture coordinates.
 *
 * @type {string}
 * @category Graphics
 */
export const SHADERPASS_UV0: string;
/**
 * This mode renders a sprite as a simple quad.
 *
 * @type {number}
 * @category Graphics
 */
export const SPRITE_RENDERMODE_SIMPLE: number;
/**
 * This mode renders a sprite using 9-slicing in 'sliced' mode. Sliced mode stretches the top and
 * bottom regions of the sprite horizontally, the left and right regions vertically and the middle
 * region both horizontally and vertically.
 *
 * @type {number}
 * @category Graphics
 */
export const SPRITE_RENDERMODE_SLICED: number;
/**
 * This mode renders a sprite using 9-slicing in 'tiled' mode. Tiled mode tiles the top and bottom
 * regions of the sprite horizontally, the left and right regions vertically and the middle region
 * both horizontally and vertically.
 *
 * @type {number}
 * @category Graphics
 */
export const SPRITE_RENDERMODE_TILED: number;
/**
 * Single color lightmap.
 *
 * @type {number}
 * @category Graphics
 */
export const BAKE_COLOR: number;
/**
 * Single color lightmap + dominant light direction (used for bump/specular).
 *
 * @type {number}
 * @category Graphics
 */
export const BAKE_COLORDIR: number;
/**
 * Center of view.
 *
 * @type {number}
 * @category Graphics
 */
export const VIEW_CENTER: number;
/**
 * Left of view. Only used in stereo rendering.
 *
 * @type {number}
 * @category Graphics
 */
export const VIEW_LEFT: number;
/**
 * Right of view. Only used in stereo rendering.
 *
 * @type {number}
 * @category Graphics
 */
export const VIEW_RIGHT: number;
/**
 * No sorting is applied. Mesh instances are rendered in the same order they were added to a layer.
 *
 * @type {number}
 * @category Graphics
 */
export const SORTMODE_NONE: number;
/**
 * Mesh instances are sorted based on {@link MeshInstance#drawOrder}.
 *
 * @type {number}
 * @category Graphics
 */
export const SORTMODE_MANUAL: number;
/**
 * Mesh instances are sorted to minimize switching between materials and meshes to improve
 * rendering performance.
 *
 * @type {number}
 * @category Graphics
 */
export const SORTMODE_MATERIALMESH: number;
/**
 * Mesh instances are sorted back to front. This is the way to properly render many
 * semi-transparent objects on different depth, one is blended on top of another.
 *
 * @type {number}
 * @category Graphics
 */
export const SORTMODE_BACK2FRONT: number;
/**
 * Mesh instances are sorted front to back. Depending on GPU and the scene, this option may give
 * better performance than {@link SORTMODE_MATERIALMESH} due to reduced overdraw.
 *
 * @type {number}
 * @category Graphics
 */
export const SORTMODE_FRONT2BACK: number;
/**
 * Provide custom functions for sorting drawcalls and calculating distance.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */
export const SORTMODE_CUSTOM: number;
/**
 * Automatically set aspect ratio to current render target's width divided by height.
 *
 * @type {number}
 * @category Graphics
 */
export const ASPECT_AUTO: number;
/**
 * Use the manual aspect ratio value.
 *
 * @type {number}
 * @category Graphics
 */
export const ASPECT_MANUAL: number;
/**
 * Horizontal orientation.
 *
 * @type {number}
 * @category Graphics
 */
export const ORIENTATION_HORIZONTAL: number;
/**
 * Vertical orientation.
 *
 * @type {number}
 * @category Graphics
 */
export const ORIENTATION_VERTICAL: number;
/**
 * A sky texture is rendered using an infinite projection.
 *
 * @type {string}
 * @category Graphics
 */
export const SKYTYPE_INFINITE: string;
/**
 * A sky texture is rendered using a box projection. This is generally suitable for interior
 * environments.
 *
 * @type {string}
 * @category Graphics
 */
export const SKYTYPE_BOX: string;
/**
 *  A sky texture is rendered using a dome projection. This is generally suitable for exterior
 * environments.
 *
 * @type {string}
 * @category Graphics
 */
export const SKYTYPE_DOME: string;
/**
 * Opacity dithering is disabled.
 *
 * @type {string}
 * @category Graphics
 */
export const DITHER_NONE: string;
/**
 * Opacity is dithered using a Bayer 8 matrix.
 *
 * @type {string}
 * @category Graphics
 */
export const DITHER_BAYER8: string;
/**
 * Opacity is dithered using a blue noise.
 *
 * @type {string}
 * @category Graphics
 */
export const DITHER_BLUENOISE: string;
/**
 * Opacity is dithered using an interleaved gradient noise.
 *
 * @type {string}
 * @category Graphics
 */
export const DITHER_IGNNOISE: string;
