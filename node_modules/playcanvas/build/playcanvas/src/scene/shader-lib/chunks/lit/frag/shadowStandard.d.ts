declare const _default: "\n// ----- Directional/Spot Sampling -----\n\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n    float z = shadowCoord.z;\n    vec2 uv = shadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n\n    float sum = 0.0;\n\n    float uw0 = (3.0 - 2.0 * s);\n    float uw1 = (1.0 + 2.0 * s);\n\n    float u0 = (2.0 - s) / uw0 - 1.0;\n    float u1 = s / uw1 + 1.0;\n\n    float vw0 = (3.0 - 2.0 * t);\n    float vw1 = (1.0 + 2.0 * t);\n\n    float v0 = (2.0 - t) / vw0 - 1.0;\n    float v1 = t / vw1 + 1.0;\n\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n\n    sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n    sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\n    sum *= 1.0f / 16.0;\n    return sum;\n}\n\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n    return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n    return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n\nfloat getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n    return textureShadow(shadowMap, shadowCoord);\n}\n\nfloat getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n    return textureShadow(shadowMap, shadowCoord);\n}\n\n// ----- Omni Sampling -----\n\n#ifndef WEBGPU\n\nfloat getShadowPointPCF3x3(samplerCubeShadow shadowMap, vec4 shadowParams, vec3 dir) {\n    \n    // Calculate shadow depth from the light direction\n    float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\n    // offset\n    float z = 1.0 / float(textureSize(shadowMap, 0));\n    vec3 tc = normalize(dir);\n\n    // average 4 samples - not a strict 3x3 PCF but that's tricky with cubemaps\n    mediump vec4 shadows;\n    shadows.x = texture(shadowMap, vec4(tc + vec3( z, z, z), shadowZ));\n    shadows.y = texture(shadowMap, vec4(tc + vec3(-z,-z, z), shadowZ));\n    shadows.z = texture(shadowMap, vec4(tc + vec3(-z, z,-z), shadowZ));\n    shadows.w = texture(shadowMap, vec4(tc + vec3( z,-z,-z), shadowZ));\n\n    return dot(shadows, vec4(0.25));\n}\n\nfloat getShadowPointPCF1x1(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n    float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n    return texture(shadowMap, vec4(lightDir, shadowZ));\n}\n\nfloat getShadowPointPCF3x3(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n    return getShadowPointPCF3x3(shadowMap, shadowParams, lightDir);\n}\n\n#endif\n";
export default _default;
