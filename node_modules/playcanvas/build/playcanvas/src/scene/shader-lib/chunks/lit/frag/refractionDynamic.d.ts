declare const _default: "\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\n\nvec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {\n\n    // The refraction point is the entry point + vector to exit point\n    vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n\n    // Project to texture space so we can sample it\n    vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n\n    // use built-in getGrabScreenPos function to convert screen position to grab texture uv coords\n    vec2 uv = getGrabScreenPos(projectionPoint);\n\n    // Use IOR and roughness to select mip\n    float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n    float refractionLod = log2(uScreenSize.x) * iorToRoughness;\n    vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;\n\n    return refraction;\n}\n\nvoid addRefraction(\n    vec3 worldNormal, \n    vec3 viewDir, \n    float thickness, \n    float gloss, \n    vec3 specularity, \n    vec3 albedo, \n    float transmission,\n    float refractionIndex,\n    float dispersion\n#if defined(LIT_IRIDESCENCE)\n    , vec3 iridescenceFresnel,\n    float iridescenceIntensity\n#endif\n) {\n\n    // Extract scale from the model transform\n    vec3 modelScale;\n    modelScale.x = length(vec3(matrix_model[0].xyz));\n    modelScale.y = length(vec3(matrix_model[1].xyz));\n    modelScale.z = length(vec3(matrix_model[2].xyz));\n\n    // Calculate the refraction vector, scaled by the thickness and scale of the object\n    vec3 scale = thickness * modelScale;\n    vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;\n    vec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);\n\n    #ifdef DISPERSION\n        // based on the dispersion material property, calculate modified refraction index values\n        // for R and B channels and evaluate the refraction color for them.\n        float halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;\n\n        float refractionIndexR = refractionIndex - halfSpread;\n        refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;\n        refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;\n\n        float refractionIndexB = refractionIndex + halfSpread;\n        refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;\n        refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;\n    #endif\n\n    // Transmittance is our final refraction color\n    vec3 transmittance;\n    if (material_invAttenuationDistance != 0.0)\n    {\n        vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n        transmittance = exp(-attenuation * length(refractionVector));\n    }\n    else\n    {\n        transmittance = refraction;\n    }\n\n    // Apply fresnel effect on refraction\n    vec3 fresnel = vec3(1.0) - \n        getFresnel(\n            dot(viewDir, worldNormal), \n            gloss, \n            specularity\n        #if defined(LIT_IRIDESCENCE)\n            , iridescenceFresnel,\n            iridescenceIntensity\n        #endif\n        );\n    dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);\n}\n";
export default _default;
