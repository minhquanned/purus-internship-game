declare const _default: "\n    #include \"decodePS\"\n    #include \"gamma\"\n    #include \"tonemapping\"\n    #include \"envMultiplyPS\"\n\n    varying vec3 vViewDir;\n    uniform float skyboxHighlightMultiplier;\n\n    #ifdef SKY_CUBEMAP\n\n        uniform samplerCube texture_cubeMap;\n\n        #ifdef SKYMESH\n            varying vec3 vWorldPos;\n            uniform mat3 cubeMapRotationMatrix;\n            uniform vec3 projectedSkydomeCenter;\n        #endif\n\n    #else // env-atlas\n\n        #include \"sphericalPS\"\n        #include \"envAtlasPS\"\n\n        uniform sampler2D texture_envAtlas;\n        uniform float mipLevel;\n\n    #endif\n\n    void main(void) {\n\n        #ifdef SKY_CUBEMAP\n\n            #ifdef SKYMESH\n\n                // get vector from world space pos to tripod origin\n                vec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);\n                vec3 dir = envDir * cubeMapRotationMatrix;\n\n            #else\n\n                vec3 dir = vViewDir;\n\n            #endif\n\n            dir.x *= -1.0;\n            vec3 linear = SKYBOX_DECODE_FNC(textureCube(texture_cubeMap, dir));\n\n        #else // env-atlas\n\n            vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n            vec2 uv = toSphericalUv(normalize(dir));\n\n            vec3 linear = SKYBOX_DECODE_FNC(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\n        #endif\n\n        // our HDR encodes values up to 64, so allow extra brightness for the clipped values\n        if (any(greaterThanEqual(linear, vec3(64.0)))) {\n            linear *= skyboxHighlightMultiplier;\n        }\n\n        gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n    }\n";
export default _default;
