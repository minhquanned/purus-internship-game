declare const _default: "\n\n/**\n * PCSS is a shadow sampling method that provides contact hardening soft shadows. \n * Based on: \n * - https://www.gamedev.net/tutorials/programming/graphics/effect-area-light-shadows-part-1-pcss-r4971/\n * - https://github.com/pboechat/PCSS \n */\n\n#define PCSS_SAMPLE_COUNT 16\nuniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];\nuniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];\n\nvec2 vogelDisk(int sampleIndex, float count, float phi, float r) {\n    const float GoldenAngle = 2.4;\n    float theta = float(sampleIndex) * GoldenAngle + phi;\n\n    float sine = sin(theta);\n    float cosine = cos(theta);\n    return vec2(r * cosine, r * sine);\n}\n\nvec3 vogelSphere(int sampleIndex, float count, float phi, float r) {\n    const float GoldenAngle = 2.4;\n    float theta = float(sampleIndex) * GoldenAngle + phi;\n\n    float weight = float(sampleIndex) / count;\n    return vec3(cos(theta) * r, weight, sin(theta) * r);\n}\n\nfloat noise(vec2 screenPos) {\n    const float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   \n    return fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);\n}\n\nfloat viewSpaceDepth(float depth, mat4 invProjection) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);\n    vec4 viewSpace = invProjection * clipSpace;\n    return viewSpace.z;\n}\n\nfloat PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {\n\n    float blockers = 0.0;\n    float averageBlocker = 0.0;\n    for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n        vec2 offset = sampleCoords[i] * searchSize;\n        vec2 sampleUV = shadowCoords + offset;\n\n        float blocker = textureLod(shadowMap, sampleUV, 0.0).r;\n        float isBlocking = step(blocker, z);\n        blockers += isBlocking;\n        averageBlocker += blocker * isBlocking;\n    }\n\n    if (blockers > 0.0)\n        return averageBlocker /= blockers;\n    return -1.0;\n}\n\nfloat PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n    float receiverDepth = shadowCoords.z;\n    vec2 samplePoints[PCSS_SAMPLE_COUNT];\n    float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n    for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n        float pcssPresample = pcssDiskSamples[i];\n        samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n    }\n\n    float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);\n    if (averageBlocker == -1.0) {\n        return 1.0;\n    } else {\n\n        vec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;\n\n        float shadow = 0.0;\n\n        for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n        {\n            vec2 sampleUV = samplePoints[i] * filterRadius;\n            sampleUV = shadowCoords.xy + sampleUV;\n\n            float depth = textureLod(shadowMap, sampleUV, 0.0).r;\n            shadow += step(receiverDepth, depth);\n        }\n        return shadow / float(PCSS_SAMPLE_COUNT);\n    } \n}\n\nfloat PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {\n    float blockers = 0.0;\n    float averageBlocker = 0.0;\n    for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n        vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;\n        sampleDir = normalize(sampleDir);\n\n        float blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n        float isBlocking = step(blocker, z);\n        blockers += isBlocking;\n        averageBlocker += blocker * isBlocking;\n    }\n\n    if (blockers > 0.0)\n        return averageBlocker /= float(blockers);\n    return -1.0;\n}\n\nfloat PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {\n    \n    vec3 samplePoints[PCSS_SAMPLE_COUNT];\n    float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n    for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n        float r = pcssSphereSamples[i];\n        samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);\n    }\n\n    float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;\n    vec3 lightDirNorm = normalize(lightDir);\n    \n    float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);\n    if (averageBlocker == -1.0) {\n        return 1.0;\n    } else {\n\n        float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n\n        float shadow = 0.0;\n        for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)\n        {\n            vec3 offset = samplePoints[i] * filterRadius;\n            vec3 sampleDir = lightDirNorm + offset;\n            sampleDir = normalize(sampleDir);\n\n            float depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n            shadow += step(receiverDepth, depth);\n        }\n        return shadow / float(PCSS_SAMPLE_COUNT);\n    }\n}\n\nfloat getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n    return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);\n}\n\nfloat getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n    return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n    return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n\n";
export default _default;
