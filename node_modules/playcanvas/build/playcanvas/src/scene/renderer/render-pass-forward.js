import { BlendState } from '../../platform/graphics/blend-state.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { RenderAction } from '../composition/render-action.js';
import { SHADER_FORWARD } from '../constants.js';

class RenderPassForward extends RenderPass {
	constructor(device, layerComposition, scene, renderer) {
		super(device);
		this.layerComposition = void 0;
		this.scene = void 0;
		this.renderer = void 0;
		this.renderActions = [];
		this.noDepthClear = false;
		this.layerComposition = layerComposition;
		this.scene = scene;
		this.renderer = renderer;
	}
	get rendersAnything() {
		return this.renderActions.length > 0;
	}
	addRenderAction(renderAction) {
		this.renderActions.push(renderAction);
	}
	addLayer(cameraComponent, layer, transparent, autoClears = true) {
		const ra = new RenderAction();
		ra.renderTarget = this.renderTarget;
		ra.camera = cameraComponent;
		ra.layer = layer;
		ra.transparent = transparent;
		if (autoClears) {
			const firstRa = this.renderActions.length === 0;
			ra.setupClears(firstRa ? cameraComponent : undefined, layer);
		}
		this.addRenderAction(ra);
	}
	addLayers(composition, cameraComponent, startIndex, firstLayerClears, lastLayerId, lastLayerIsTransparent = true) {
		const {
			layerList,
			subLayerList
		} = composition;
		let clearRenderTarget = firstLayerClears;
		let index = startIndex;
		while (index < layerList.length) {
			const layer = layerList[index];
			const isTransparent = subLayerList[index];
			const renderedByCamera = cameraComponent.camera.layersSet.has(layer.id);
			if (renderedByCamera) {
				this.addLayer(cameraComponent, layer, isTransparent, clearRenderTarget);
				clearRenderTarget = false;
			}
			index++;
			if (layer.id === lastLayerId && isTransparent === lastLayerIsTransparent) {
				break;
			}
		}
		return index;
	}
	updateDirectionalShadows() {
		const {
			renderer,
			renderActions
		} = this;
		for (let i = 0; i < renderActions.length; i++) {
			const renderAction = renderActions[i];
			const cameraComp = renderAction.camera;
			const camera = cameraComp.camera;
			const shadowDirLights = this.renderer.cameraDirShadowLights.get(camera);
			if (shadowDirLights) {
				for (let l = 0; l < shadowDirLights.length; l++) {
					const light = shadowDirLights[l];
					if (renderer.dirLightShadows.get(light) !== camera) {
						renderer.dirLightShadows.set(light, camera);
						const shadowPass = renderer._shadowRendererDirectional.getLightRenderPass(light, camera);
						if (shadowPass) {
							this.beforePasses.push(shadowPass);
						}
					}
				}
			}
		}
	}
	updateClears() {
		const renderAction = this.renderActions[0];
		if (renderAction) {
			const cameraComponent = renderAction.camera;
			const camera = cameraComponent.camera;
			const fullSizeClearRect = camera.fullSizeClearRect;
			this.setClearColor(fullSizeClearRect && renderAction.clearColor ? camera.clearColor : undefined);
			this.setClearDepth(fullSizeClearRect && renderAction.clearDepth && !this.noDepthClear ? camera.clearDepth : undefined);
			this.setClearStencil(fullSizeClearRect && renderAction.clearStencil ? camera.clearStencil : undefined);
		}
	}
	frameUpdate() {
		super.frameUpdate();
		this.updateDirectionalShadows();
		this.updateClears();
	}
	before() {
		const {
			renderActions
		} = this;
		for (let i = 0; i < renderActions.length; i++) {
			const ra = renderActions[i];
			if (ra.firstCameraUse) {
				ra.camera.onPreRender == null || ra.camera.onPreRender();
			}
		}
	}
	execute() {
		const {
			layerComposition,
			renderActions
		} = this;
		for (let i = 0; i < renderActions.length; i++) {
			const ra = renderActions[i];
			const layer = ra.layer;
			if (layerComposition.isEnabled(layer, ra.transparent)) {
				this.renderRenderAction(ra, i === 0);
			}
		}
	}
	after() {
		for (let i = 0; i < this.renderActions.length; i++) {
			const ra = this.renderActions[i];
			if (ra.lastCameraUse) {
				ra.camera.onPostRender == null || ra.camera.onPostRender();
			}
		}
		this.beforePasses.length = 0;
	}
	renderRenderAction(renderAction, firstRenderAction) {
		const {
			renderer
		} = this;
		const device = renderer.device;
		const {
			layer,
			transparent,
			camera
		} = renderAction;
		if (camera) {
			var _camera$camera$shader, _camera$camera$shader2, _renderAction$renderT;
			camera.onPreRenderLayer == null || camera.onPreRenderLayer(layer, transparent);
			const options = {
				lightClusters: renderAction.lightClusters
			};
			const shaderPass = (_camera$camera$shader = (_camera$camera$shader2 = camera.camera.shaderPassInfo) == null ? void 0 : _camera$camera$shader2.index) != null ? _camera$camera$shader : SHADER_FORWARD;
			if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
				options.clearColor = renderAction.clearColor;
				options.clearDepth = renderAction.clearDepth;
				options.clearStencil = renderAction.clearStencil;
			}
			const renderTarget = (_renderAction$renderT = renderAction.renderTarget) != null ? _renderAction$renderT : device.backBuffer;
			renderer.renderForwardLayer(camera.camera, renderTarget, layer, transparent, shaderPass, renderAction.viewBindGroups, options);
			device.setBlendState(BlendState.NOBLEND);
			device.setStencilState(null, null);
			device.setAlphaToCoverage(false);
			camera.onPostRenderLayer == null || camera.onPostRenderLayer(layer, transparent);
		}
	}
}

export { RenderPassForward };
