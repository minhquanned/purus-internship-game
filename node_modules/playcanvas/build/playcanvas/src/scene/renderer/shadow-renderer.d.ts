export class ShadowRenderer {
    static createShadowCamera(device: any, shadowType: any, type: any, face: any): Camera;
    /**
     * @param {Renderer} renderer - The renderer.
     * @param {LightTextureAtlas} lightTextureAtlas - The shadow map atlas.
     */
    constructor(renderer: Renderer, lightTextureAtlas: LightTextureAtlas);
    /**
     * A cache of shadow passes. First index is looked up by light type, second by shadow type.
     *
     * @type {ShaderPassInfo[][]}
     * @private
     */
    private shadowPassCache;
    device: import("../../index.js").GraphicsDevice;
    /** @type {Renderer} */
    renderer: Renderer;
    /** @type {LightTextureAtlas} */
    lightTextureAtlas: LightTextureAtlas;
    sourceId: import("../../index.js").ScopeId;
    pixelOffsetId: import("../../index.js").ScopeId;
    weightId: import("../../index.js").ScopeId;
    blurVsmShaderCode: string[];
    blurPackedVsmShaderCode: string[];
    blurVsmShader: {}[];
    blurPackedVsmShader: {}[];
    blurVsmWeights: {};
    shadowMapLightRadiusId: import("../../index.js").ScopeId;
    viewUniformFormat: UniformBufferFormat;
    viewBindGroupFormat: BindGroupFormat;
    blendStateWrite: BlendState;
    blendStateNoWrite: BlendState;
    shadowRenderingParams: RenderingParams;
    _cullShadowCastersInternal(meshInstances: any, visible: any, camera: any): void;
    /**
     * Culls the list of shadow casters used by the light by the camera, storing visible mesh
     * instances in the specified array.
     *
     * @param {LayerComposition} comp - The layer composition used as a source of shadow casters,
     * if those are not provided directly.
     * @param {Light} light - The light.
     * @param {MeshInstance[]} visible - The array to store visible mesh instances in.
     * @param {Camera} camera - The camera.
     * @param {MeshInstance[]} [casters] - Optional array of mesh instances to use as casters.
     */
    cullShadowCasters(comp: LayerComposition, light: Light, visible: MeshInstance[], camera: Camera, casters?: MeshInstance[]): void;
    setupRenderState(device: any, light: any): void;
    dispatchUniforms(light: any, shadowCam: any, lightRenderData: any, face: any): void;
    /**
     * @param {Light} light - The light.
     * @returns {number} Index of shadow pass info.
     */
    getShadowPass(light: Light): number;
    /**
     * @param {MeshInstance[]} visibleCasters - Visible mesh instances.
     * @param {Light} light - The light.
     */
    submitCasters(visibleCasters: MeshInstance[], light: Light): void;
    needsShadowRendering(light: any): any;
    getLightRenderData(light: any, camera: any, face: any): any;
    setupRenderPass(renderPass: any, shadowCamera: any, clearRenderTarget: any): void;
    prepareFace(light: any, camera: any, face: any): any;
    renderFace(light: any, camera: any, face: any, clear: any, insideRenderPass?: boolean): void;
    render(light: any, camera: any, insideRenderPass?: boolean): void;
    renderVsm(light: any, camera: any): void;
    getVsmBlurShader(isVsm8: any, blurMode: any, filterSize: any): any;
    applyVsmBlur(light: any, camera: any): void;
    initViewBindGroupFormat(): void;
    frameUpdate(): void;
}
import type { Renderer } from './renderer.js';
import type { LightTextureAtlas } from '../lighting/light-texture-atlas.js';
import { UniformBufferFormat } from '../../platform/graphics/uniform-buffer-format.js';
import { BindGroupFormat } from '../../platform/graphics/bind-group-format.js';
import { BlendState } from '../../platform/graphics/blend-state.js';
import { RenderingParams } from './rendering-params.js';
import type { LayerComposition } from '../composition/layer-composition.js';
import type { Light } from '../light.js';
import type { MeshInstance } from '../mesh-instance.js';
import type { Camera } from '../camera.js';
