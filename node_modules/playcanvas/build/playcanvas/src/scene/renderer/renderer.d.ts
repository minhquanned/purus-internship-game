/**
 * The base renderer functionality to allow implementation of specialized renderers.
 *
 * @ignore
 */
export class Renderer {
    /**
     * Create a new instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used by the renderer.
     */
    constructor(graphicsDevice: GraphicsDevice);
    /** @type {boolean} */
    clustersDebugRendered: boolean;
    /**
     * A set of visible mesh instances which need further processing before being rendered, e.g.
     * skinning or morphing. Extracted during culling.
     *
     * @type {Set<MeshInstance>}
     * @private
     */
    private processingMeshInstances;
    /**
     * @type {WorldClustersAllocator}
     * @ignore
     */
    worldClustersAllocator: WorldClustersAllocator;
    /**
     * A list of all unique lights in the layer composition.
     *
     * @type {Light[]}
     */
    lights: Light[];
    /**
     * A list of all unique local lights (spot & omni) in the layer composition.
     *
     * @type {Light[]}
     */
    localLights: Light[];
    /**
     * A list of unique directional shadow casting lights for each enabled camera. This is generated
     * each frame during light culling.
     *
     * @type {Map<Camera, Array<Light>>}
     */
    cameraDirShadowLights: Map<Camera, Array<Light>>;
    /**
     * A mapping of a directional light to a camera, for which the shadow is currently valid. This
     * is cleared each frame, and updated each time a directional light shadow is rendered for a
     * camera, and allows us to manually schedule shadow passes when a new camera needs a shadow.
     *
     * @type {Map<Light, Camera>}
     */
    dirLightShadows: Map<Light, Camera>;
    blueNoise: BlueNoise;
    device: GraphicsDevice;
    /** @type {Scene|null} */
    scene: Scene | null;
    lightTextureAtlas: LightTextureAtlas;
    shadowMapCache: ShadowMapCache;
    shadowRenderer: ShadowRenderer;
    _shadowRendererLocal: ShadowRendererLocal;
    _shadowRendererDirectional: ShadowRendererDirectional;
    _renderPassUpdateClustered: RenderPassUpdateClustered;
    viewUniformFormat: UniformBufferFormat;
    viewBindGroupFormat: BindGroupFormat;
    _skinTime: number;
    _morphTime: number;
    _cullTime: number;
    _shadowMapTime: number;
    _lightClustersTime: number;
    _layerCompositionUpdateTime: number;
    _shadowDrawCalls: number;
    _skinDrawCalls: number;
    _instancedDrawCalls: number;
    _shadowMapUpdates: number;
    _numDrawCallsCulled: number;
    _camerasRendered: number;
    _lightClusters: number;
    boneTextureId: import("../../index.js").ScopeId;
    boneTextureSizeId: import("../../index.js").ScopeId;
    modelMatrixId: import("../../index.js").ScopeId;
    normalMatrixId: import("../../index.js").ScopeId;
    viewInvId: import("../../index.js").ScopeId;
    viewPos: Float32Array;
    viewPosId: import("../../index.js").ScopeId;
    projId: import("../../index.js").ScopeId;
    projSkyboxId: import("../../index.js").ScopeId;
    viewId: import("../../index.js").ScopeId;
    viewId3: import("../../index.js").ScopeId;
    viewProjId: import("../../index.js").ScopeId;
    flipYId: import("../../index.js").ScopeId;
    tbnBasis: import("../../index.js").ScopeId;
    nearClipId: import("../../index.js").ScopeId;
    farClipId: import("../../index.js").ScopeId;
    cameraParams: Float32Array;
    cameraParamsId: import("../../index.js").ScopeId;
    viewIndexId: import("../../index.js").ScopeId;
    blueNoiseJitterVersion: number;
    blueNoiseJitterVec: Vec4;
    blueNoiseJitterData: Float32Array;
    blueNoiseJitterId: import("../../index.js").ScopeId;
    blueNoiseTextureId: import("../../index.js").ScopeId;
    alphaTestId: import("../../index.js").ScopeId;
    opacityMapId: import("../../index.js").ScopeId;
    exposureId: import("../../index.js").ScopeId;
    twoSidedLightingNegScaleFactorId: import("../../index.js").ScopeId;
    morphPositionTex: import("../../index.js").ScopeId;
    morphNormalTex: import("../../index.js").ScopeId;
    morphTexParams: import("../../index.js").ScopeId;
    lightCube: LightCube;
    constantLightCube: import("../../index.js").ScopeId;
    destroy(): void;
    sortCompare(drawCallA: any, drawCallB: any): number;
    sortCompareMesh(drawCallA: any, drawCallB: any): number;
    sortCompareDepth(drawCallA: any, drawCallB: any): number;
    /**
     * Set up the viewport and the scissor for camera rendering.
     *
     * @param {Camera} camera - The camera containing the viewport information.
     * @param {RenderTarget} [renderTarget] - The render target. NULL for the default one.
     */
    setupViewport(camera: Camera, renderTarget?: RenderTarget): void;
    setCameraUniforms(camera: any, target: any): number;
    /**
     * Clears the active render target. If the viewport is already set up, only its area is cleared.
     *
     * @param {Camera} camera - The camera supplying the value to clear to.
     * @param {boolean} [clearColor] - True if the color buffer should be cleared. Uses the value
     * from the camera if not supplied.
     * @param {boolean} [clearDepth] - True if the depth buffer should be cleared. Uses the value
     * from the camera if not supplied.
     * @param {boolean} [clearStencil] - True if the stencil buffer should be cleared. Uses the
     * value from the camera if not supplied.
     */
    clear(camera: Camera, clearColor?: boolean, clearDepth?: boolean, clearStencil?: boolean): void;
    setCamera(camera: any, target: any, clear: any, renderAction?: any): void;
    clearView(camera: any, target: any, clear: any, forceWrite: any): void;
    setupCullMode(cullFaces: any, flipFactor: any, drawCall: any): void;
    updateCameraFrustum(camera: any): void;
    setBaseConstants(device: any, material: any): void;
    updateCpuSkinMatrices(drawCalls: any): void;
    /**
     * Update skin matrices ahead of rendering.
     *
     * @param {MeshInstance[]|Set<MeshInstance>} drawCalls - MeshInstances containing skinInstance.
     * @ignore
     */
    updateGpuSkinMatrices(drawCalls: MeshInstance[] | Set<MeshInstance>): void;
    /**
     * Update morphing ahead of rendering.
     *
     * @param {MeshInstance[]|Set<MeshInstance>} drawCalls - MeshInstances containing morphInstance.
     * @ignore
     */
    updateMorphing(drawCalls: MeshInstance[] | Set<MeshInstance>): void;
    /**
     * Update gsplats ahead of rendering.
     *
     * @param {MeshInstance[]|Set<MeshInstance>} drawCalls - MeshInstances containing gsplatInstances.
     * @ignore
     */
    updateGSplats(drawCalls: MeshInstance[] | Set<MeshInstance>): void;
    /**
     * Update draw calls ahead of rendering.
     *
     * @param {MeshInstance[]|Set<MeshInstance>} drawCalls - MeshInstances requiring updates.
     * @ignore
     */
    gpuUpdate(drawCalls: MeshInstance[] | Set<MeshInstance>): void;
    setVertexBuffers(device: any, mesh: any): void;
    setMorphing(device: any, morphInstance: any): void;
    setSkinning(device: any, meshInstance: any): void;
    dispatchViewPos(position: any): void;
    initViewBindGroupFormat(isClustered: any): void;
    setupViewUniformBuffers(viewBindGroups: any, viewUniformFormat: any, viewBindGroupFormat: any, viewCount: any): void;
    setupMeshUniformBuffers(shaderInstance: any, meshInstance: any): void;
    drawInstance(device: any, meshInstance: any, mesh: any, style: any, normal: any): void;
    drawInstance2(device: any, meshInstance: any, mesh: any, style: any): void;
    /**
     * @param {Camera} camera - The camera used for culling.
     * @param {MeshInstance[]} drawCalls - Draw calls to cull.
     * @param {CulledInstances} culledInstances - Stores culled instances.
     */
    cull(camera: Camera, drawCalls: MeshInstance[], culledInstances: CulledInstances): void;
    collectLights(comp: any): void;
    cullLights(camera: any, lights: any): void;
    /**
     * Shadow map culling for directional and visible local lights visible meshInstances are
     * collected into light._renderData, and are marked as visible for directional lights also
     * shadow camera matrix is set up.
     *
     * @param {LayerComposition} comp - The layer composition.
     */
    cullShadowmaps(comp: LayerComposition): void;
    /**
     * visibility culling of lights, meshInstances, shadows casters. Also applies
     * `meshInstance.visible`.
     *
     * @param {LayerComposition} comp - The layer composition.
     */
    cullComposition(comp: LayerComposition): void;
    /**
     * @param {MeshInstance[]} drawCalls - Mesh instances.
     * @param {boolean} onlyLitShaders - Limits the update to shaders affected by lighting.
     */
    updateShaders(drawCalls: MeshInstance[], onlyLitShaders: boolean): void;
    updateFrameUniforms(): void;
    /**
     * @param {LayerComposition} comp - The layer composition to update.
     */
    beginFrame(comp: LayerComposition): void;
    updateLightTextureAtlas(): void;
    /**
     * Updates the layer composition for rendering.
     *
     * @param {LayerComposition} comp - The layer composition to update.
     */
    updateLayerComposition(comp: LayerComposition): void;
    frameUpdate(): void;
}
import { WorldClustersAllocator } from './world-clusters-allocator.js';
import type { Light } from '../light.js';
import type { Camera } from '../camera.js';
import { BlueNoise } from '../../core/math/blue-noise.js';
import type { GraphicsDevice } from '../../platform/graphics/graphics-device.js';
import type { Scene } from '../scene.js';
import { LightTextureAtlas } from '../lighting/light-texture-atlas.js';
import { ShadowMapCache } from './shadow-map-cache.js';
import { ShadowRenderer } from './shadow-renderer.js';
import { ShadowRendererLocal } from './shadow-renderer-local.js';
import { ShadowRendererDirectional } from './shadow-renderer-directional.js';
import { RenderPassUpdateClustered } from './render-pass-update-clustered.js';
import { UniformBufferFormat } from '../../platform/graphics/uniform-buffer-format.js';
import { BindGroupFormat } from '../../platform/graphics/bind-group-format.js';
import { Vec4 } from '../../core/math/vec4.js';
import { LightCube } from '../graphics/light-cube.js';
import type { RenderTarget } from '../../platform/graphics/render-target.js';
import type { MeshInstance } from '../mesh-instance.js';
import type { CulledInstances } from '../layer.js';
import type { LayerComposition } from '../composition/layer-composition.js';
