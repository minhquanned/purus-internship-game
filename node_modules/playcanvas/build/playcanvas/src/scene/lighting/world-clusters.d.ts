export class WorldClusters {
    constructor(device: any);
    /** @type {Texture} */
    clusterTexture: Texture;
    device: any;
    name: string;
    reportCount: number;
    boundsMin: Vec3;
    boundsMax: Vec3;
    boundsDelta: Vec3;
    _cells: Vec3;
    _cellsLimit: Vec3;
    set cells(value: Vec3);
    get cells(): Vec3;
    set maxCellLightCount(count: any);
    get maxCellLightCount(): any;
    _maxAttenuation: number;
    _maxColorValue: number;
    _usedLights: ClusterLight[];
    lightsBuffer: LightsBuffer;
    _maxCellLightCount: any;
    _cellsDirty: boolean;
    destroy(): void;
    releaseClusterTexture(): void;
    registerUniforms(device: any): void;
    _clusterSkipId: any;
    _clusterMaxCellsId: any;
    _clusterWorldTextureId: any;
    _clusterTextureSizeId: any;
    _clusterTextureSizeData: Float32Array;
    _clusterBoundsMinId: any;
    _clusterBoundsMinData: Float32Array;
    _clusterBoundsDeltaId: any;
    _clusterBoundsDeltaData: Float32Array;
    _clusterCellsCountByBoundsSizeId: any;
    _clusterCellsCountByBoundsSizeData: Float32Array;
    _clusterCellsDotId: any;
    _clusterCellsDotData: Float32Array;
    _clusterCellsMaxId: any;
    _clusterCellsMaxData: Float32Array;
    _clusterCompressionLimit0Id: any;
    _clusterCompressionLimit0Data: Float32Array;
    updateParams(lightingParams: any): void;
    updateCells(): void;
    clusters: Uint8ClampedArray;
    counts: Int32Array;
    uploadTextures(): void;
    updateUniforms(): void;
    evalLightCellMinMax(clusteredLight: any, min: any, max: any): void;
    collectLights(lights: any): void;
    evaluateBounds(): void;
    evaluateCompressionLimits(): void;
    updateClusters(lightingParams: any): void;
    update(lights: any, lightingParams?: any): void;
    activate(): void;
}
import type { Texture } from '../../platform/graphics/texture.js';
import { Vec3 } from '../../core/math/vec3.js';
declare class ClusterLight {
    light: any;
    min: Vec3;
    max: Vec3;
}
import { LightsBuffer } from './lights-buffer.js';
export {};
