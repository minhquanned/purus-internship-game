import { LAYERID_SKYBOX, LAYERID_IMMEDIATE, GAMMA_NONE, TONEMAP_NONE } from '../../scene/constants.js';
import { PIXELFORMAT_RGBA8, FILTER_LINEAR, ADDRESS_CLAMP_TO_EDGE, FILTER_NEAREST, PIXELFORMAT_DEPTH, PIXELFORMAT_R32F } from '../../platform/graphics/constants.js';
import { Texture } from '../../platform/graphics/texture.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { RenderPassColorGrab } from '../../scene/graphics/render-pass-color-grab.js';
import { RenderPassForward } from '../../scene/renderer/render-pass-forward.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { RenderPassBloom } from './render-pass-bloom.js';
import { RenderPassCompose } from './render-pass-compose.js';
import { RenderPassTAA } from './render-pass-taa.js';
import { RenderPassPrepass } from './render-pass-prepass.js';
import { RenderPassSsao } from './render-pass-ssao.js';
import { RenderingParams } from '../../scene/renderer/rendering-params.js';

const SSAOTYPE_NONE = 'none';
const SSAOTYPE_LIGHTING = 'lighting';
const SSAOTYPE_COMBINE = 'combine';
class CameraFrameOptions {
	constructor() {
		this.formats = void 0;
		this.samples = 1;
		this.sceneColorMap = false;
		this.lastGrabLayerId = LAYERID_SKYBOX;
		this.lastGrabLayerIsTransparent = false;
		this.lastSceneLayerId = LAYERID_IMMEDIATE;
		this.lastSceneLayerIsTransparent = true;
		this.taaEnabled = false;
		this.bloomEnabled = false;
		this.ssaoType = SSAOTYPE_NONE;
		this.ssaoBlurEnabled = true;
		this.prepassEnabled = false;
	}
}
const _defaultOptions = new CameraFrameOptions();
class RenderPassCameraFrame extends RenderPass {
	constructor(app, cameraComponent, options = {}) {
		super(app.graphicsDevice);
		this.app = void 0;
		this.prePass = void 0;
		this.scenePass = void 0;
		this.composePass = void 0;
		this.bloomPass = void 0;
		this.ssaoPass = void 0;
		this.taaPass = void 0;
		this._renderTargetScale = 1;
		this.rt = null;
		this.app = app;
		this.cameraComponent = cameraComponent;
		this.options = this.sanitizeOptions(options);
		this.setupRenderPasses(this.options);
	}
	destroy() {
		this.reset();
	}
	reset() {
		this.sceneTexture = null;
		this.sceneDepth = null;
		if (this.rt) {
			this.rt.destroyTextureBuffers();
			this.rt.destroy();
			this.rt = null;
		}
		this.beforePasses.forEach(pass => pass.destroy());
		this.beforePasses.length = 0;
		this.prePass = null;
		this.scenePass = null;
		this.scenePassTransparent = null;
		this.colorGrabPass = null;
		this.composePass = null;
		this.bloomPass = null;
		this.ssaoPass = null;
		this.taaPass = null;
		this.afterPass = null;
	}
	sanitizeOptions(options) {
		options = Object.assign({}, _defaultOptions, options);
		if (options.taaEnabled || options.ssaoType !== SSAOTYPE_NONE) {
			options.prepassEnabled = true;
		}
		return options;
	}
	set renderTargetScale(value) {
		this._renderTargetScale = value;
		if (this.scenePass) {
			this.scenePass.options.scaleX = value;
			this.scenePass.options.scaleY = value;
		}
	}
	get renderTargetScale() {
		return this._renderTargetScale;
	}
	needsReset(options) {
		const currentOptions = this.options;
		const arraysNotEqual = (arr1, arr2) => arr1 !== arr2 && (!(Array.isArray(arr1) && Array.isArray(arr2)) || arr1.length !== arr2.length || !arr1.every((value, index) => value === arr2[index]));
		return options.ssaoType !== currentOptions.ssaoType || options.ssaoBlurEnabled !== currentOptions.ssaoBlurEnabled || options.taaEnabled !== currentOptions.taaEnabled || options.samples !== currentOptions.samples || options.bloomEnabled !== currentOptions.bloomEnabled || options.prepassEnabled !== currentOptions.prepassEnabled || options.sceneColorMap !== currentOptions.sceneColorMap || arraysNotEqual(options.formats, currentOptions.formats);
	}
	update(options) {
		options = this.sanitizeOptions(options);
		if (this.needsReset(options)) {
			this.reset();
		}
		this.options = options;
		if (!this.sceneTexture) {
			this.setupRenderPasses(this.options);
		}
	}
	setupRenderPasses(options) {
		const {
			device
		} = this;
		const cameraComponent = this.cameraComponent;
		const targetRenderTarget = cameraComponent.renderTarget;
		this.hdrFormat = device.getRenderableHdrFormat(options.formats, true, options.samples) || PIXELFORMAT_RGBA8;
		if (!cameraComponent.rendering) {
			cameraComponent.rendering = new RenderingParams();
		}
		const rendering = cameraComponent.rendering;
		rendering.gammaCorrection = GAMMA_NONE;
		rendering.toneMapping = TONEMAP_NONE;
		rendering.ssaoEnabled = options.ssaoType === SSAOTYPE_LIGHTING;
		this.sceneTexture = new Texture(device, {
			name: 'SceneColor',
			width: 4,
			height: 4,
			format: this.hdrFormat,
			mipmaps: false,
			minFilter: FILTER_LINEAR,
			magFilter: FILTER_LINEAR,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		let depthFormat = PIXELFORMAT_DEPTH;
		if (options.prepassEnabled && device.isWebGPU && options.samples > 1) {
			depthFormat = PIXELFORMAT_R32F;
		}
		this.sceneDepth = new Texture(device, {
			name: 'SceneDepth',
			width: 4,
			height: 4,
			format: depthFormat,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		this.rt = new RenderTarget({
			colorBuffer: this.sceneTexture,
			depthBuffer: this.sceneDepth,
			samples: options.samples,
			flipY: !!(targetRenderTarget != null && targetRenderTarget.flipY)
		});
		this.sceneOptions = {
			resizeSource: targetRenderTarget,
			scaleX: this.renderTargetScale,
			scaleY: this.renderTargetScale
		};
		this.createPasses(options);
		const allPasses = this.collectPasses();
		this.beforePasses = allPasses.filter(element => element !== undefined && element !== null);
	}
	collectPasses() {
		return [this.prePass, this.ssaoPass, this.scenePass, this.colorGrabPass, this.scenePassTransparent, this.taaPass, this.bloomPass, this.composePass, this.afterPass];
	}
	createPasses(options) {
		this.setupScenePrepass(options);
		this.setupSsaoPass(options);
		const scenePassesInfo = this.setupScenePass(options);
		const sceneTextureWithTaa = this.setupTaaPass(options);
		this.setupBloomPass(options, sceneTextureWithTaa);
		this.setupComposePass(options);
		this.setupAfterPass(options, scenePassesInfo);
	}
	setupScenePrepass(options) {
		if (options.prepassEnabled) {
			const {
				app,
				device,
				cameraComponent
			} = this;
			const {
				scene,
				renderer
			} = app;
			const resolveDepth = this.options.ssaoType !== SSAOTYPE_NONE || this.options.taaEnabled;
			this.prePass = new RenderPassPrepass(device, scene, renderer, cameraComponent, this.sceneDepth, resolveDepth, this.sceneOptions, options.samples);
		}
	}
	setupScenePass(options) {
		const {
			app,
			device,
			cameraComponent
		} = this;
		const {
			scene,
			renderer
		} = app;
		const composition = scene.layers;
		this.scenePass = new RenderPassForward(device, composition, scene, renderer);
		this.scenePass.init(this.rt, this.sceneOptions);
		if (options.prepassEnabled) {
			this.scenePass.noDepthClear = true;
			this.scenePass.depthStencilOps.storeDepth = true;
		}
		const lastLayerId = options.sceneColorMap ? options.lastGrabLayerId : options.lastSceneLayerId;
		const lastLayerIsTransparent = options.sceneColorMap ? options.lastGrabLayerIsTransparent : options.lastSceneLayerIsTransparent;
		const ret = {
			lastAddedIndex: 0,
			clearRenderTarget: true
		};
		ret.lastAddedIndex = this.scenePass.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, lastLayerId, lastLayerIsTransparent);
		ret.clearRenderTarget = false;
		if (options.sceneColorMap) {
			this.colorGrabPass = new RenderPassColorGrab(device);
			this.colorGrabPass.source = this.rt;
			this.scenePassTransparent = new RenderPassForward(device, composition, scene, renderer);
			this.scenePassTransparent.init(this.rt);
			ret.lastAddedIndex = this.scenePassTransparent.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, options.lastSceneLayerId, options.lastSceneLayerIsTransparent);
			if (!this.scenePassTransparent.rendersAnything) {
				this.scenePassTransparent.destroy();
				this.scenePassTransparent = null;
			}
			if (this.scenePassTransparent) {
				if (options.prepassEnabled) {
					this.scenePassTransparent.depthStencilOps.storeDepth = true;
				}
			}
		}
		return ret;
	}
	setupSsaoPass(options) {
		const {
			camera,
			ssaoBlurEnabled,
			ssaoType
		} = options;
		if (ssaoType !== SSAOTYPE_NONE) {
			this.ssaoPass = new RenderPassSsao(this.device, this.sceneTexture, camera, ssaoBlurEnabled);
		}
	}
	setupBloomPass(options, inputTexture) {
		if (options.bloomEnabled && this.hdrFormat !== PIXELFORMAT_RGBA8) {
			this.bloomPass = new RenderPassBloom(this.device, inputTexture, this.hdrFormat);
		}
	}
	setupTaaPass(options) {
		let textureWithTaa = this.sceneTexture;
		if (options.taaEnabled) {
			const cameraComponent = this.cameraComponent;
			this.taaPass = new RenderPassTAA(this.device, this.sceneTexture, cameraComponent);
			textureWithTaa = this.taaPass.historyTexture;
		}
		return textureWithTaa;
	}
	setupComposePass(options) {
		var _this$bloomPass;
		this.composePass = new RenderPassCompose(this.device);
		this.composePass.bloomTexture = (_this$bloomPass = this.bloomPass) == null ? void 0 : _this$bloomPass.bloomTexture;
		this.composePass.taaEnabled = options.taaEnabled;
		const cameraComponent = this.cameraComponent;
		const targetRenderTarget = cameraComponent.renderTarget;
		this.composePass.init(targetRenderTarget);
		this.composePass.ssaoTexture = options.ssaoType === SSAOTYPE_COMBINE ? this.ssaoPass.ssaoTexture : null;
	}
	setupAfterPass(options, scenePassesInfo) {
		const {
			app,
			cameraComponent
		} = this;
		const {
			scene,
			renderer
		} = app;
		const composition = scene.layers;
		const targetRenderTarget = cameraComponent.renderTarget;
		this.afterPass = new RenderPassForward(this.device, composition, scene, renderer);
		this.afterPass.init(targetRenderTarget);
		this.afterPass.addLayers(composition, cameraComponent, scenePassesInfo.lastAddedIndex, scenePassesInfo.clearRenderTarget);
	}
	frameUpdate() {
		var _this$taaPass$update, _this$taaPass;
		super.frameUpdate();
		const sceneTexture = (_this$taaPass$update = (_this$taaPass = this.taaPass) == null ? void 0 : _this$taaPass.update()) != null ? _this$taaPass$update : this.rt.colorBuffer;
		this.composePass.sceneTexture = sceneTexture;
		if (this.options.bloomEnabled && this.bloomPass) {
			this.bloomPass.sourceTexture = sceneTexture;
		}
	}
}

export { CameraFrameOptions, RenderPassCameraFrame, SSAOTYPE_COMBINE, SSAOTYPE_LIGHTING, SSAOTYPE_NONE };
