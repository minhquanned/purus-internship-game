import { math } from '../../core/math/math.js';
import { Vec3 } from '../../core/math/vec3.js';
import { Mat4 } from '../../core/math/mat4.js';
import { Ray } from '../../core/shape/ray.js';
import { EventHandler } from '../../core/event-handler.js';
import { SORTMODE_NONE, PROJECTION_PERSPECTIVE } from '../../scene/constants.js';
import { Entity } from '../../framework/entity.js';
import { Layer } from '../../scene/layer.js';
import { GIZMOSPACE_WORLD, GIZMOSPACE_LOCAL } from './constants.js';

const tmpV1 = new Vec3();
const tmpM1 = new Mat4();
const tmpM2 = new Mat4();
const tmpR1 = new Ray();
const LAYER_NAME = 'Gizmo';
const MIN_SCALE = 1e-4;
const PERS_SCALE_RATIO = 0.3;
const ORTHO_SCALE_RATIO = 0.32;
const UPDATE_EPSILON = 1e-6;
class Gizmo extends EventHandler {
	static createLayer(app, layerName = LAYER_NAME, layerIndex) {
		const layer = new Layer({
			name: layerName,
			clearDepthBuffer: true,
			opaqueSortMode: SORTMODE_NONE,
			transparentSortMode: SORTMODE_NONE
		});
		app.scene.layers.insert(layer, layerIndex != null ? layerIndex : app.scene.layers.layerList.length);
		return layer;
	}
	constructor(camera, layer) {
		super();
		this._size = 1;
		this._scale = 1;
		this._coordSpace = GIZMOSPACE_WORLD;
		this._app = void 0;
		this._device = void 0;
		this._camera = void 0;
		this._layer = void 0;
		this.nodes = [];
		this.root = void 0;
		this.intersectData = [];
		this._camera = camera;
		this._app = camera.system.app;
		this._device = this._app.graphicsDevice;
		this._layer = layer;
		camera.layers = camera.layers.concat(layer.id);
		this.root = new Entity('gizmo');
		this._app.root.addChild(this.root);
		this.root.enabled = false;
		this._updateScale();
		this._onPointerDown = this._onPointerDown.bind(this);
		this._onPointerMove = this._onPointerMove.bind(this);
		this._onPointerUp = this._onPointerUp.bind(this);
		this._device.canvas.addEventListener('pointerdown', this._onPointerDown);
		this._device.canvas.addEventListener('pointermove', this._onPointerMove);
		this._device.canvas.addEventListener('pointerup', this._onPointerUp);
		this._app.on('update', () => {
			this._updatePosition();
			this._updateRotation();
			this._updateScale();
		});
		this._app.on('destroy', () => this.destroy());
	}
	get layer() {
		return this._layer;
	}
	set coordSpace(value) {
		this._coordSpace = value != null ? value : GIZMOSPACE_WORLD;
		this._updateRotation();
	}
	get coordSpace() {
		return this._coordSpace;
	}
	set size(value) {
		this._size = value;
		this._updateScale();
	}
	get size() {
		return this._size;
	}
	_onPointerDown(e) {
		if (!this.root.enabled || document.pointerLockElement) {
			return;
		}
		const selection = this._getSelection(e.offsetX, e.offsetY);
		if (selection[0]) {
			e.preventDefault();
			e.stopPropagation();
		}
		const {
			canvas
		} = this._device;
		canvas.setPointerCapture(e.pointerId);
		this.fire(Gizmo.EVENT_POINTERDOWN, e.offsetX, e.offsetY, selection[0]);
	}
	_onPointerMove(e) {
		if (!this.root.enabled || document.pointerLockElement) {
			return;
		}
		const selection = this._getSelection(e.offsetX, e.offsetY);
		if (selection[0]) {
			e.preventDefault();
			e.stopPropagation();
		}
		this.fire(Gizmo.EVENT_POINTERMOVE, e.offsetX, e.offsetY, selection[0]);
	}
	_onPointerUp(e) {
		if (!this.root.enabled || document.pointerLockElement) {
			return;
		}
		const {
			canvas
		} = this._device;
		canvas.releasePointerCapture(e.pointerId);
		this.fire(Gizmo.EVENT_POINTERUP);
	}
	_updatePosition() {
		tmpV1.set(0, 0, 0);
		for (let i = 0; i < this.nodes.length; i++) {
			const node = this.nodes[i];
			tmpV1.add(node.getPosition());
		}
		tmpV1.mulScalar(1.0 / (this.nodes.length || 1));
		if (tmpV1.distance(this.root.getPosition()) < UPDATE_EPSILON) {
			return;
		}
		this.root.setPosition(tmpV1);
		this.fire(Gizmo.EVENT_POSITIONUPDATE, tmpV1);
	}
	_updateRotation() {
		tmpV1.set(0, 0, 0);
		if (this._coordSpace === GIZMOSPACE_LOCAL && this.nodes.length !== 0) {
			tmpV1.copy(this.nodes[this.nodes.length - 1].getEulerAngles());
		}
		if (tmpV1.distance(this.root.getEulerAngles()) < UPDATE_EPSILON) {
			return;
		}
		this.root.setEulerAngles(tmpV1);
		this.fire(Gizmo.EVENT_ROTATIONUPDATE, tmpV1);
	}
	_updateScale() {
		if (this._camera.projection === PROJECTION_PERSPECTIVE) {
			const gizmoPos = this.root.getPosition();
			const cameraPos = this._camera.entity.getPosition();
			const dist = gizmoPos.distance(cameraPos);
			this._scale = Math.tan(0.5 * this._camera.fov * math.DEG_TO_RAD) * dist * PERS_SCALE_RATIO;
		} else {
			this._scale = this._camera.orthoHeight * ORTHO_SCALE_RATIO;
		}
		this._scale = Math.max(this._scale * this._size, MIN_SCALE);
		if (Math.abs(this._scale - this.root.getLocalScale().x) < UPDATE_EPSILON) {
			return;
		}
		this.root.setLocalScale(this._scale, this._scale, this._scale);
		this.fire(Gizmo.EVENT_SCALEUPDATE, this._scale);
	}
	_getSelection(x, y) {
		const start = this._camera.screenToWorld(x, y, this._camera.nearClip);
		const end = this._camera.screenToWorld(x, y, this._camera.farClip);
		const dir = end.clone().sub(start).normalize();
		const selection = [];
		for (let i = 0; i < this.intersectData.length; i++) {
			const {
				triData,
				parent,
				meshInstances
			} = this.intersectData[i];
			const parentTM = parent.getWorldTransform();
			for (let j = 0; j < triData.length; j++) {
				const {
					tris,
					transform,
					priority
				} = triData[j];
				const triWTM = tmpM1.copy(parentTM).mul(transform);
				const invTriWTM = tmpM2.copy(triWTM).invert();
				const ray = tmpR1;
				invTriWTM.transformPoint(start, ray.origin);
				invTriWTM.transformVector(dir, ray.direction);
				ray.direction.normalize();
				for (let k = 0; k < tris.length; k++) {
					if (tris[k].intersectsRay(ray, tmpV1)) {
						selection.push({
							dist: triWTM.transformPoint(tmpV1).sub(start).length(),
							meshInstances: meshInstances,
							priority: priority
						});
					}
				}
			}
		}
		if (selection.length) {
			selection.sort((s0, s1) => {
				if (s0.priority !== 0 && s1.priority !== 0) {
					return s1.priority - s0.priority;
				}
				return s0.dist - s1.dist;
			});
			return selection[0].meshInstances;
		}
		return [];
	}
	attach(nodes = []) {
		if (Array.isArray(nodes)) {
			if (nodes.length === 0) {
				return;
			}
			this.nodes = nodes;
		} else {
			this.nodes = [nodes];
		}
		this._updatePosition();
		this._updateRotation();
		this._updateScale();
		this.fire(Gizmo.EVENT_NODESATTACH);
		this.root.enabled = true;
		this.fire(Gizmo.EVENT_RENDERUPDATE);
	}
	detach() {
		this.root.enabled = false;
		this.fire(Gizmo.EVENT_RENDERUPDATE);
		this.fire(Gizmo.EVENT_NODESDETACH);
		this.nodes = [];
	}
	destroy() {
		this.detach();
		this._device.canvas.removeEventListener('pointerdown', this._onPointerDown);
		this._device.canvas.removeEventListener('pointermove', this._onPointerMove);
		this._device.canvas.removeEventListener('pointerup', this._onPointerUp);
		this.root.destroy();
	}
}
Gizmo.EVENT_POINTERDOWN = 'pointer:down';
Gizmo.EVENT_POINTERMOVE = 'pointer:move';
Gizmo.EVENT_POINTERUP = 'pointer:up';
Gizmo.EVENT_POSITIONUPDATE = 'position:update';
Gizmo.EVENT_ROTATIONUPDATE = 'rotation:update';
Gizmo.EVENT_SCALEUPDATE = 'scale:update';
Gizmo.EVENT_NODESATTACH = 'nodes:attach';
Gizmo.EVENT_NODESDETACH = 'nodes:detach';
Gizmo.EVENT_RENDERUPDATE = 'render:update';

export { Gizmo };
